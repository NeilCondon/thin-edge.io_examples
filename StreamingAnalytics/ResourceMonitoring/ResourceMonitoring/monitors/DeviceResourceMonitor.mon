using com.apama.aggregates.mean;

/**
 *  This monitor is responsible for process and aggregate the cpu and memory usage measurments received over a
 *  certain period of time. If reports the average values to the cloud for cpu/memory usage in an interval of 
 *  five minutes if the average breaches THRESHOLD values, otherwise it does an hourly paper report.
 */
monitor DeviceResourceMonitor {

	constant string MQTT_SEND_CHANNEL := "out";
	constant string PROCESSED_MEASUREMENTS_CHANNEL := "PROCESSED_MEASUREMENTS_CHANNEL";

	constant float ONE_HOUR_INTERVAL := 120.0;
	constant float FIVE_MINS_INTERVAL := 10.0;

	constant float CPU_AVERAGE_THRESHOLD := 70.0;
	constant float MEM_AVERAGE_THRESHOLD := 70.0;

	integer cpuReadings := 0;
	float cpuPercentCMA := 0.0;
	float lastCpuReportTime := 0.0;
	listener nextCpuReportWait;

	integer memReadings := 0;
	float memPercentCMA := 0.0;
	float lastMemReportTime := 0.0;
	listener nextMemReportWait;

	action onload() {
		log "Loaded monitor DeviceResourceMonitor" at INFO;
		monitor.subscribe(PROCESSED_MEASUREMENTS_CHANNEL);

		// schedule the initial reports on load
		nextCpuReportWait := scheduleNextHourlyReport(nextCpuReportWait, paperReportCpuUsage);
		nextMemReportWait := scheduleNextHourlyReport(nextMemReportWait, paperReportMemoryUsage);

		// stream of cpu measurements
		stream<CpuMeasurement> cpuMeasurementStream := all CpuMeasurement();

		// report lastFiveMinAverage of cpu measurements if it has breached CPU_AVERAGE_THRESHOLD
		// and we have not reported in the last FIVE_MINS_INTERVAL
		from cpuMeasurement in cpuMeasurementStream within FIVE_MINS_INTERVAL select mean(cpuMeasurement.cpuMeasurement) as lastFiveMinAverage {
			if (lastFiveMinAverage >= CPU_AVERAGE_THRESHOLD and lastCpuReportTime + FIVE_MINS_INTERVAL <= currentTime) {
				reportCpuUsage(lastFiveMinAverage);
			}
		}

		// maintain an overall average in case it is going to be an hourly paper report
		from cpuMeasurement in cpuMeasurementStream select cpuMeasurement.cpuMeasurement as measurement {
			// calculate the cumulative average of the readings received since the last cpu usage report to the cloud
			cpuPercentCMA := cpuPercentCMA + (measurement - cpuPercentCMA)/(cpuReadings + 1).toFloat();
			cpuReadings := cpuReadings + 1;
		}

		// set up the same for memory usage measurements
		stream<MemMeasurement> memMeasurementStream := all MemMeasurement();

		from memMeasurement in memMeasurementStream within FIVE_MINS_INTERVAL select mean(memMeasurement.memMeasurement) as lastFiveMinAverage {
				if (lastFiveMinAverage >= MEM_AVERAGE_THRESHOLD and lastMemReportTime + FIVE_MINS_INTERVAL <= currentTime) {
					reportMemoryUsage(lastFiveMinAverage);
				}
			}

		from memMeasurement in memMeasurementStream select memMeasurement.memMeasurement as measurement {
			memPercentCMA := memPercentCMA + (measurement - memPercentCMA)/(memReadings + 1).toFloat();
			memReadings := memReadings + 1;
		}

	}

	action reportCpuUsage(float averageCpuUsage) {
		float reportingTime := currentTime;
		send RawCpuMeasurement(reportingTime.toString() + ":" + averageCpuUsage.toString()) to MQTT_SEND_CHANNEL;

		// reset the cpu variables
		cpuReadings := 0;
		cpuPercentCMA := 0.0;
		lastCpuReportTime := reportingTime;

		// schedule the next report
		nextCpuReportWait := scheduleNextHourlyReport(nextCpuReportWait, paperReportCpuUsage);
	}

	action paperReportCpuUsage() {
		reportCpuUsage(memPercentCMA);
	}

	action reportMemoryUsage(float averageMemUsage) {
		float reportingTime := currentTime;
		send RawMemMeasurement(reportingTime.toString() + ":" + averageMemUsage.toString()) to MQTT_SEND_CHANNEL;

		// reset the mem variables
		memReadings := 0;
		memPercentCMA := 0.0;
		lastMemReportTime := reportingTime;

		// schedule the next paper report
		nextMemReportWait := scheduleNextHourlyReport(nextMemReportWait, paperReportMemoryUsage);
	}

	action paperReportMemoryUsage() {
		reportMemoryUsage(memPercentCMA);
	}

	action scheduleNextHourlyReport(listener currentWaitListener, action<> reportUsageAction) returns listener {
		currentWaitListener.quit();
		listener newWaitListener := on wait(ONE_HOUR_INTERVAL) {
			reportUsageAction();
		}
		return newWaitListener;
	}
}
