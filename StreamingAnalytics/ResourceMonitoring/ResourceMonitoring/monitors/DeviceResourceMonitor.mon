using com.apama.aggregates.count;

/**
 *  This monitor is responsible for processing the cpu and memory usage measurments received over a certain period
 *  of time. It reports the percentage of that time period for which a particular usage was above THRESHOLD value.
 *  It reports to the cloud in FIVE_MINS_INTERVALs if the last five minutes high usage percentage is above PERCENTILE_THRESHOLD.
 *  otherwise it does an hourly paper report.
 */
monitor DeviceResourceMonitor {

	constant string MQTT_SEND_CHANNEL := "out";
	constant string PROCESSED_MEASUREMENTS_CHANNEL := "PROCESSED_MEASUREMENTS_CHANNEL";

	constant float ONE_HOUR_INTERVAL := 3600.0;
	constant float FIVE_MINS_INTERVAL := 300.0;

	constant float CPU_THRESHOLD := 70.0;
	constant float MEM_THRESHOLD := 70.0;

	constant float CPU_PERCENTILE_THRESHOLD := 70.0;
	constant float MEM_PERCENTILE_THRESHOLD := 70.0;

	integer cpuReadings := 0;
	float highCpuTimeFraction := 0.0;
	float lastCpuReportTime := 0.0;
	listener nextCpuReportWait;

	integer memReadings := 0;
	float highMemTimeFraction := 0.0;
	float lastMemReportTime := 0.0;
	listener nextMemReportWait;

	action onload() {
		log "Loaded monitor DeviceResourceMonitor" at INFO;
		monitor.subscribe(PROCESSED_MEASUREMENTS_CHANNEL);

		// schedule the initial reports on load
		nextCpuReportWait := scheduleNextHourlyReport(nextCpuReportWait, paperReportCpuUsage);
		nextMemReportWait := scheduleNextHourlyReport(nextMemReportWait, paperReportMemoryUsage);

		// stream of cpu measurements
		stream<CpuMeasurement> cpuMeasurementStream := all CpuMeasurement();

		// derived streams of total cpu measuerment counts and counts of measurements above CPU_THRESHOLD within last FIVE_MINS_INTERVAL
		stream<integer> windowTotalCpuUsageCounts := from measurement in cpuMeasurementStream within FIVE_MINS_INTERVAL select count();
		stream<integer> windowHighCpuUsageCounts := from measurement in cpuMeasurementStream within FIVE_MINS_INTERVAL select count(measurement.percentActive >= CPU_THRESHOLD);

		// calculate the time percentage for which cpu usage was above CPU_THRESHOLD within FIVE_MINS_INTERVAL
		// report lastFiveMinHighUsgaePercentage if it has breached CPU_PERCENTILE_THRESHOLD and it has been five mins since last report
		from highUsageCount in windowHighCpuUsageCounts from totalCount in windowTotalCpuUsageCounts select 100.0 * highUsageCount.toFloat()/totalCount.toFloat() as lastFiveMinHighUsgaePercentage {
			if (lastFiveMinHighUsgaePercentage >= CPU_PERCENTILE_THRESHOLD and lastCpuReportTime + FIVE_MINS_INTERVAL <= currentTime) {
				reportCpuUsage(lastFiveMinHighUsgaePercentage);
			}
		}

		// maintain an overall time fraction of high usage since the last report in case it is going to be an hourly paper report
		from cpuMeasurement in cpuMeasurementStream select cpuMeasurement.percentActive as measurement {
			// calculate the cumulative percentile of the readings received since the last cpu usage report to the cloud
			integer newReading := 0;
			if measurement >= CPU_THRESHOLD {
				newReading := 1;
			}
			highCpuTimeFraction := highCpuTimeFraction + (newReading.toFloat() - highCpuTimeFraction)/(cpuReadings + 1).toFloat();
			cpuReadings := cpuReadings + 1;
		}

		// set up the same for memory usage measurements
		stream<MemMeasurement> memMeasurementStream := all MemMeasurement();

		stream<integer> windowHighMemUsageCounts := from measurement in memMeasurementStream within FIVE_MINS_INTERVAL select count(measurement.percentUsed >= MEM_THRESHOLD);
		stream<integer> windowTotalMemUsageCounts := from measurement in memMeasurementStream within FIVE_MINS_INTERVAL select count();

		from highUsageCount in windowHighMemUsageCounts from totalCount in windowTotalMemUsageCounts select 100.0 * highUsageCount.toFloat()/totalCount.toFloat() as lastFiveMinHighUsgaePercentage {
			if (lastFiveMinHighUsgaePercentage >= MEM_PERCENTILE_THRESHOLD and lastMemReportTime + FIVE_MINS_INTERVAL <= currentTime) {
				reportMemoryUsage(lastFiveMinHighUsgaePercentage);
			}
		}

		from memMeasurement in memMeasurementStream select memMeasurement.percentUsed as measurement {
			integer newReading := 0;
			if measurement >= MEM_THRESHOLD {
				newReading := 1;
			}
			highMemTimeFraction := highMemTimeFraction + (newReading.toFloat() - highMemTimeFraction)/(memReadings + 1).toFloat();
			memReadings := memReadings + 1;
		}

	}

	action reportCpuUsage(float averageCpuUsage) {
		float reportingTime := currentTime;
		send RawCpuMeasurement(reportingTime.toString() + ":" + averageCpuUsage.toString()) to MQTT_SEND_CHANNEL;

		// reset the cpu variables
		cpuReadings := 0;
		highCpuTimeFraction := 0.0;
		lastCpuReportTime := reportingTime;

		// schedule the next report
		nextCpuReportWait := scheduleNextHourlyReport(nextCpuReportWait, paperReportCpuUsage);
	}

	action paperReportCpuUsage() {
		reportCpuUsage(highCpuTimeFraction * 100.0);
	}

	action reportMemoryUsage(float averageMemUsage) {
		float reportingTime := currentTime;
		send RawMemMeasurement(reportingTime.toString() + ":" + averageMemUsage.toString()) to MQTT_SEND_CHANNEL;

		// reset the mem variables
		memReadings := 0;
		highMemTimeFraction := 0.0;
		lastMemReportTime := reportingTime;

		// schedule the next paper report
		nextMemReportWait := scheduleNextHourlyReport(nextMemReportWait, paperReportMemoryUsage);
	}

	action paperReportMemoryUsage() {
		reportMemoryUsage(highMemTimeFraction * 100.0);
	}

	action scheduleNextHourlyReport(listener currentWaitListener, action<> reportUsageAction) returns listener {
		currentWaitListener.quit();
		listener newWaitListener := on wait(ONE_HOUR_INTERVAL) {
			reportUsageAction();
		}
		return newWaitListener;
	}
}
