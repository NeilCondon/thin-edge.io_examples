import * as tslib_1 from "tslib";
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { ComponentFactory, ComponentFactoryResolver, Directive, EmbeddedViewRef, Input, SimpleChanges, TemplateRef, Type, ViewContainerRef, ViewRef } from '@angular/core';
import { assign, get } from 'lodash-es';
import { isObservable, of, pipe, Subject } from 'rxjs';
import { map, takeUntil, tap } from 'rxjs/operators';
import { LoadMoreComponent } from './load-more.component';
/**
 * A directive to iterate over IResultList<T> data from @c8y/client.
 * Depending on the [c8yForLoadMore] a load more button is:
 *  - auto: Tries to automatically load more data (default maximum 10 iterations; can be
 *          change with maxIterations settings).
 *  - show: Shows a load more button for the user to decide
 *  - none: Doesn't perform any load more action.
 *  - hidden: Loads more data automatically but with no visible button for the user.
 *
 * Additional, any rxjs operator pipe can be applied to the [c8yForPipe] input, e.g. to
 * filter the data displayed currently as well as the data loaded by subsequent requests.
 *
 * Example:
 * ```html
 * <div *c8yFor="let device of devices; loadMore: 'auto'; let i = index; pipe: filterPipe;">
 *  {{ i + 1 }}. {{device.name}}
 * </div>
 * ```
 * The above example will list all entities that are applied to `devices`:
 * ```typescript
 * this.devices = this.inventoryService.list({ pageSize: 10, fragmentType: 'c8y_IsDevice' })
 * ```
 * It will display the first 10 items, if there is more space left on the screen, and there are more
 * than 10 devices, it will automatically load up to 10 pages more. If it still can't fit the screen
 * it will stop and switch to `show` mode.
 *
 * A pipe can be applied e.g. for filtering or grouping. This pipe is attached to every follow up
 * request done by the load more component:
 * ```typescript
 * this.filterPipe = pipe(
 *    map((data: []) => {
 *     return data.filter(
 *      (mo: any) => mo.name && mo.name.toLowerCase().indexOf(value.toLowerCase()) > -1
 *    );
 *  })
 * );
 * ```
 * The pipe must be an rxjs pipe and can take any operator.
 */
let ForOfDirective = class ForOfDirective {
    constructor(tpl, vcr, componentFactoryResolver) {
        this.tpl = tpl;
        this.vcr = vcr;
        this.componentFactoryResolver = componentFactoryResolver;
        this.cachedData = [];
        this.loadMoreMode = 'auto';
        this.dataPipe = pipe(tap());
        this.maxIterations = 10;
        this.unsubscribe$ = new Subject();
    }
    get shouldUseLoadMoreButton() {
        return (this.loadMoreMode === 'auto' || this.loadMoreMode === 'show' || this.loadMoreMode === 'hidden');
    }
    get hasMoreData() {
        return this.loadMore && this.loadMore.hasMore;
    }
    get length() {
        return this.cachedData.length;
    }
    /**
     * The data setter. Must be a response from @c8y/data or an observable.
     * You can pass an observable with null to explicitly clear the list.
     */
    set c8yForOf(fetchData) {
        if (fetchData) {
            this.obs$ = (isObservable(fetchData) ? fetchData : of(fetchData)).pipe(map(result => {
                if (result === null) {
                    this.paging = null;
                    return [];
                }
                const { paging, data } = result;
                this.paging = paging;
                return data;
            }));
        }
    }
    /**
     * The mode setter:
     *  - auto: Tries to automatically load more data (default maximum 10 iterations; can be
     *          change with maxIterations settings).
     *  - show: Shows a load more button for the user to decide
     *  - none: Doesn't perform any load more action.
     *  - hidden: Loads more data automatically but with no visible button for the user.
     */
    set c8yForLoadMore(type) {
        this.loadMoreMode = type;
    }
    /**
     * The pipe setter to attach any rxjs pipe to the current and more loaded data.
     */
    set c8yForPipe(dataPipe) {
        if (dataPipe) {
            this.dataPipe = dataPipe;
        }
    }
    /**
     * A template to use if no data is found at all (e.g. if you apply a filter pipe).
     */
    set c8yForNotFound(notFoundTemplate) {
        this.notFoundTemplate = notFoundTemplate;
        if (this.loadMore) {
            this.loadMore.noMoreDataHint = notFoundTemplate;
        }
    }
    /**
     * The maximum numbers of iterations to call data from the api.
     */
    set c8yForMaxIterations(maxIterations) {
        this.maxIterations = maxIterations;
    }
    /**
     * A custom loading component.
     */
    set c8yForLoadingTemplate(loadingTemplate) {
        this.loadingTemplate = loadingTemplate;
    }
    /**
     * Load next text label.
     */
    set c8yForLoadNextLabel(loadNextLabel) {
        this.loadNextLabel = loadNextLabel;
    }
    /**
     * A RealtimeService instance.
     */
    set c8yForRealtime(source) {
        this.realtime = source;
    }
    /**
     * A comparator function for comparing list items. Used to determine
     * the position at which a new element should be added to the list.
     */
    set c8yForComparator(comparator) {
        this.comparator = comparator;
    }
    ngOnInit() {
        this.handleRealtime();
    }
    ngOnChanges(changes) {
        if (this.obs$ && (changes.c8yForPipe || changes.c8yForOf)) {
            this.unsubscribePaging();
            // only re-rendering  on filtering if all data is already loaded
            // from the backend
            const reRender = !this.hasMoreData && !!changes.c8yForPipe && !changes.c8yForOf;
            if (reRender) {
                this.obs$ = of(this.cachedData);
            }
            this.pagingSub = this.obs$
                .pipe(tap(data => {
                if (!reRender) {
                    this.cachedData = data;
                }
            }))
                .pipe(src => this.dataPipe(src))
                .subscribe((data) => {
                this.render(data, reRender);
            });
        }
    }
    ngOnDestroy() {
        this.unsubscribePaging();
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    handleRealtime() {
        if (this.realtime) {
            this.realtime
                .onCreate$()
                .pipe(takeUntil(this.unsubscribe$))
                .subscribe(item => this.insert(item));
            this.realtime
                .onUpdate$()
                .pipe(takeUntil(this.unsubscribe$))
                .subscribe(item => this.update(item));
            this.realtime
                .onDelete$()
                .pipe(takeUntil(this.unsubscribe$))
                .subscribe(id => this.remove(coerceNumberProperty(id)));
        }
    }
    render(data, reRender = false) {
        this.vcr.clear();
        data.forEach((item, index) => {
            const context = {
                $implicit: item,
                index,
                length: this.length,
                hasMore: this.hasMoreData,
                loadMoreComponent: this.loadMore
            };
            this.vcr.createEmbeddedView(this.tpl, context);
        });
        if (this.shouldUseLoadMoreButton) {
            this.loadMore = this.createLoadMoreButtonComponent(reRender);
        }
    }
    append(data) {
        data.forEach(item => {
            const index = this.shouldUseLoadMoreButton ? this.vcr.length - 1 : this.vcr.length;
            const context = {
                $implicit: item,
                index,
                length: this.length,
                hasMore: this.hasMoreData,
                loadMoreComponent: this.loadMore
            };
            this.vcr.createEmbeddedView(this.tpl, context, index);
        });
    }
    loadMoreData(data) {
        if (data.length > 0) {
            this.append(data);
        }
    }
    createLoadMoreButtonComponent(reRender) {
        const componentFactory = this.componentFactoryResolver.resolveComponentFactory(LoadMoreComponent);
        const componentRef = this.vcr.createComponent(componentFactory);
        const instance = componentRef.instance;
        instance.paging = this.paging;
        instance.useIntersection = this.loadMoreMode === 'auto' || this.loadMoreMode === 'hidden';
        instance.hidden = this.loadMoreMode === 'hidden';
        instance.maxIterations = this.maxIterations;
        instance.noMoreDataHint = this.notFoundTemplate;
        instance.loadingTemplate = this.loadingTemplate;
        instance.loadNextLabel = this.loadNextLabel;
        this.pagingSub = instance.onLoad
            .pipe(map((data) => this.checkForDuplicates(data)), tap((data) => {
            this.cachedData = this.cachedData.concat(data);
        }))
            .pipe(src => this.dataPipe(src))
            .subscribe(data => this.loadMoreData(data));
        if (reRender) {
            assign(instance, this.loadMore);
        }
        return instance;
    }
    insert(item) {
        let index = 0;
        if (this.comparator && this.cachedData.length) {
            let comparisionResult;
            do {
                const view = this.vcr.get(index);
                const itemB = get(view, 'context.$implicit');
                comparisionResult = item && itemB ? this.comparator(item, itemB) : 0;
                if (comparisionResult <= 0) {
                    index++;
                }
            } while (comparisionResult <= 0 && index < this.cachedData.length);
        }
        // Do not append elements after the last one currently loaded,
        // as it may belong further down there on the list and will
        // be eventually loaded with one of the next pages.
        if (index < this.cachedData.length || this.cachedData.length === 0) {
            const context = {
                $implicit: item,
                index,
                length: this.length,
                hasMore: this.hasMoreData
            };
            this.cachedData.splice(index, 0, item);
            const viewRef = this.tpl.createEmbeddedView(context);
            this.vcr.insert(viewRef, index);
        }
    }
    update(updatedItem) {
        this.forMatchingEmbeddedViewRef((item) => item && updatedItem && item.id === updatedItem.id, (view) => {
            view.context.$implicit = updatedItem;
            view.markForCheck();
        });
    }
    remove(idToRemove) {
        this.forMatchingEmbeddedViewRef((item) => item && coerceNumberProperty(item.id, NaN) === idToRemove, (view) => view.destroy());
    }
    forMatchingEmbeddedViewRef(filter, callback) {
        for (let i = 0; i < this.vcr.length; i++) {
            const view = this.vcr.get(i);
            const item = get(view, 'context.$implicit');
            if (filter(item)) {
                callback(view);
            }
        }
    }
    checkForDuplicates(data) {
        return this.realtime
            ? data.filter(item => !this.cachedData.some(cached => cached.id === item.id))
            : data;
    }
    unsubscribePaging() {
        if (this.pagingSub) {
            this.pagingSub.unsubscribe();
        }
    }
};
ForOfDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver }
];
tslib_1.__decorate([
    Input()
], ForOfDirective.prototype, "c8yForOf", null);
tslib_1.__decorate([
    Input()
], ForOfDirective.prototype, "c8yForLoadMore", null);
tslib_1.__decorate([
    Input()
], ForOfDirective.prototype, "c8yForPipe", null);
tslib_1.__decorate([
    Input()
], ForOfDirective.prototype, "c8yForNotFound", null);
tslib_1.__decorate([
    Input()
], ForOfDirective.prototype, "c8yForMaxIterations", null);
tslib_1.__decorate([
    Input()
], ForOfDirective.prototype, "c8yForLoadingTemplate", null);
tslib_1.__decorate([
    Input()
], ForOfDirective.prototype, "c8yForLoadNextLabel", null);
tslib_1.__decorate([
    Input()
], ForOfDirective.prototype, "c8yForRealtime", null);
tslib_1.__decorate([
    Input()
], ForOfDirective.prototype, "c8yForComparator", null);
ForOfDirective = tslib_1.__decorate([
    Directive({
        selector: '[c8yFor]'
    })
], ForOfDirective);
export { ForOfDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yT2YuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGM4eS9uZ3gtY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbImNvcmUvY29tbW9uL2Zvck9mLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDN0QsT0FBTyxFQUNMLGdCQUFnQixFQUNoQix3QkFBd0IsRUFDeEIsU0FBUyxFQUNULGVBQWUsRUFDZixLQUFLLEVBQ0wsYUFBYSxFQUNiLFdBQVcsRUFDWCxJQUFJLEVBQ0osZ0JBQWdCLEVBQ2hCLE9BQU8sRUFDUixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUN4QyxPQUFPLEVBQUUsWUFBWSxFQUFjLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUNqRixPQUFPLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVyRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUcxRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQ0c7QUFJSCxJQUFhLGNBQWMsR0FBM0IsTUFBYSxjQUFjO0lBOEh6QixZQUNVLEdBQXFCLEVBQ3JCLEdBQXFCLEVBQ3JCLHdCQUFrRDtRQUZsRCxRQUFHLEdBQUgsR0FBRyxDQUFrQjtRQUNyQixRQUFHLEdBQUgsR0FBRyxDQUFrQjtRQUNyQiw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQTBCO1FBaElwRCxlQUFVLEdBQWtCLEVBQUUsQ0FBQztRQUUvQixpQkFBWSxHQUFpQixNQUFNLENBQUM7UUFDcEMsYUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBS3ZCLGtCQUFhLEdBQUcsRUFBRSxD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LElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzdFLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDWCxDQUFDO0lBRU8saUJBQWlCO1FBQ3ZCLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNsQixJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQzlCO0lBQ0gsQ0FBQztDQUNGLENBQUE7O1lBdE1nQixXQUFXO1lBQ1gsZ0JBQWdCO1lBQ0ssd0JBQXdCOztBQTlGNUQ7SUFEQyxLQUFLLEVBQUU7OENBZVA7QUFXRDtJQURDLEtBQUssRUFBRTtvREFHUDtBQU1EO0lBREMsS0FBSyxFQUFFO2dEQUtQO0FBTUQ7SUFEQyxLQUFLLEVBQUU7b0RBTVA7QUFNRDtJQURDLEtBQUssRUFBRTt5REFHUDtBQU1EO0lBREMsS0FBSyxFQUFFOzJEQUdQO0FBTUQ7SUFEQyxLQUFLLEVBQUU7eURBR1A7QUFNRDtJQURDLEtBQUssRUFBRTtvREFHUDtBQU9EO0lBREMsS0FBSyxFQUFFO3NEQUdQO0FBNUhVLGNBQWM7SUFIMUIsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLFVBQVU7S0FDckIsQ0FBQztHQUNXLGNBQWMsQ0FxVTFCO1NBclVZLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2VyY2VOdW1iZXJQcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQge1xuICBDb21wb25lbnRGYWN0b3J5LFxuICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gIERpcmVjdGl2ZSxcbiAgRW1iZWRkZWRWaWV3UmVmLFxuICBJbnB1dCxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgVGVtcGxhdGVSZWYsXG4gIFR5cGUsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIFZpZXdSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJSWRlbnRpZmllZCwgSVJlc3VsdExpc3QsIFBhZ2luZyB9IGZyb20gJ0BjOHkvY2xpZW50JztcbmltcG9ydCB7IGFzc2lnbiwgZ2V0IH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IGlzT2JzZXJ2YWJsZSwgT2JzZXJ2YWJsZSwgb2YsIHBpcGUsIFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCB0YWtlVW50aWwsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFJlYWx0aW1lU2VydmljZSB9IGZyb20gJy4uL3JlYWx0aW1lL3JlYWx0aW1lLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9hZE1vcmVDb21wb25lbnQgfSBmcm9tICcuL2xvYWQtbW9yZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgTG9hZE1vcmVNb2RlIH0gZnJvbSAnLi9sb2FkLW1vcmUubW9kZWwnO1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRvIGl0ZXJhdGUgb3ZlciBJUmVzdWx0TGlzdDxUPiBkYXRhIGZyb20gQGM4eS9jbGllbnQuXG4gKiBEZXBlbmRpbmcgb24gdGhlIFtjOHlGb3JMb2FkTW9yZV0gYSBsb2FkIG1vcmUgYnV0dG9uIGlzOlxuICogIC0gYXV0bzogVHJpZXMgdG8gYXV0b21hdGljYWxseSBsb2FkIG1vcmUgZGF0YSAoZGVmYXVsdCBtYXhpbXVtIDEwIGl0ZXJhdGlvbnM7IGNhbiBiZVxuICogICAgICAgICAgY2hhbmdlIHdpdGggbWF4SXRlcmF0aW9ucyBzZXR0aW5ncykuXG4gKiAgLSBzaG93OiBTaG93cyBhIGxvYWQgbW9yZSBidXR0b24gZm9yIHRoZSB1c2VyIHRvIGRlY2lkZVxuICogIC0gbm9uZTogRG9lc24ndCBwZXJmb3JtIGFueSBsb2FkIG1vcmUgYWN0aW9uLlxuICogIC0gaGlkZGVuOiBMb2FkcyBtb3JlIGRhdGEgYXV0b21hdGljYWxseSBidXQgd2l0aCBubyB2aXNpYmxlIGJ1dHRvbiBmb3IgdGhlIHVzZXIuXG4gKlxuICogQWRkaXRpb25hbCwgYW55IHJ4anMgb3BlcmF0b3IgcGlwZSBjYW4gYmUgYXBwbGllZCB0byB0aGUgW2M4eUZvclBpcGVdIGlucHV0LCBlLmcuIHRvXG4gKiBmaWx0ZXIgdGhlIGRhdGEgZGlzcGxheWVkIGN1cnJlbnRseSBhcyB3ZWxsIGFzIHRoZSBkYXRhIGxvYWRlZCBieSBzdWJzZXF1ZW50IHJlcXVlc3RzLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8ZGl2ICpjOHlGb3I9XCJsZXQgZGV2aWNlIG9mIGRldmljZXM7IGxvYWRNb3JlOiAnYXV0byc7IGxldCBpID0gaW5kZXg7IHBpcGU6IGZpbHRlclBpcGU7XCI+XG4gKiAge3sgaSArIDEgfX0uIHt7ZGV2aWNlLm5hbWV9fVxuICogPC9kaXY+XG4gKiBgYGBcbiAqIFRoZSBhYm92ZSBleGFtcGxlIHdpbGwgbGlzdCBhbGwgZW50aXRpZXMgdGhhdCBhcmUgYXBwbGllZCB0byBgZGV2aWNlc2A6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiB0aGlzLmRldmljZXMgPSB0aGlzLmludmVudG9yeVNlcnZpY2UubGlzdCh7IHBhZ2VTaXplOiAxMCwgZnJhZ21lbnRUeXBlOiAnYzh5X0lzRGV2aWNlJyB9KVxuICogYGBgXG4gKiBJdCB3aWxsIGRpc3BsYXkgdGhlIGZpcnN0IDEwIGl0ZW1zLCBpZiB0aGVyZSBpcyBtb3JlIHNwYWNlIGxlZnQgb24gdGhlIHNjcmVlbiwgYW5kIHRoZXJlIGFyZSBtb3JlXG4gKiB0aGFuIDEwIGRldmljZXMsIGl0IHdpbGwgYXV0b21hdGljYWxseSBsb2FkIHVwIHRvIDEwIHBhZ2VzIG1vcmUuIElmIGl0IHN0aWxsIGNhbid0IGZpdCB0aGUgc2NyZWVuXG4gKiBpdCB3aWxsIHN0b3AgYW5kIHN3aXRjaCB0byBgc2hvd2AgbW9kZS5cbiAqXG4gKiBBIHBpcGUgY2FuIGJlIGFwcGxpZWQgZS5nLiBmb3IgZmlsdGVyaW5nIG9yIGdyb3VwaW5nLiBUaGlzIHBpcGUgaXMgYXR0YWNoZWQgdG8gZXZlcnkgZm9sbG93IHVwXG4gKiByZXF1ZXN0IGRvbmUgYnkgdGhlIGxvYWQgbW9yZSBjb21wb25lbnQ6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiB0aGlzLmZpbHRlclBpcGUgPSBwaXBlKFxuICogICAgbWFwKChkYXRhOiBbXSkgPT4ge1xuICogICAgIHJldHVybiBkYXRhLmZpbHRlcihcbiAqICAgICAgKG1vOiBhbnkpID0+IG1vLm5hbWUgJiYgbW8ubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgPiAtMVxuICogICAgKTtcbiAqICB9KVxuICogKTtcbiAqIGBgYFxuICogVGhlIHBpcGUgbXVzdCBiZSBhbiByeGpzIHBpcGUgYW5kIGNhbiB0YWtlIGFueSBvcGVyYXRvci5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2M4eUZvcl0nXG59KVxuZXhwb3J0IGNsYXNzIEZvck9mRGlyZWN0aXZlIHtcbiAgcHJpdmF0ZSBjYWNoZWREYXRhOiBJSWRlbnRpZmllZFtdID0gW107XG4gIHByaXZhdGUgcGFnaW5nOiBQYWdpbmc8SUlkZW50aWZpZWQ+O1xuICBwcml2YXRlIGxvYWRNb3JlTW9kZTogTG9hZE1vcmVNb2RlID0gJ2F1dG8nO1xuICBwcml2YXRlIGRhdGFQaXBlID0gcGlwZSh0YXAoKSk7XG4gIHByaXZhdGUgcGFnaW5nU3ViOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgb2JzJDogT2JzZXJ2YWJsZTxJSWRlbnRpZmllZFtdPjtcbiAgcHJpdmF0ZSBsb2FkTW9yZTogTG9hZE1vcmVDb21wb25lbnQ7XG4gIHByaXZhdGUgbG9hZGluZ1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICBwcml2YXRlIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgcHJpdmF0ZSBub3RGb3VuZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICBwcml2YXRlIGxvYWROZXh0TGFiZWw6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFsdGltZTogUmVhbHRpbWVTZXJ2aWNlPGFueT47XG4gIHByaXZhdGUgY29tcGFyYXRvcjogKGl0ZW1BOiBvYmplY3QsIGl0ZW1COiBvYmplY3QpID0+IG51bWJlcjtcbiAgcHJpdmF0ZSB1bnN1YnNjcmliZSQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdCgpO1xuXG4gIHByaXZhdGUgZ2V0IHNob3VsZFVzZUxvYWRNb3JlQnV0dG9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmxvYWRNb3JlTW9kZSA9PT0gJ2F1dG8nIHx8IHRoaXMubG9hZE1vcmVNb2RlID09PSAnc2hvdycgfHwgdGhpcy5sb2FkTW9yZU1vZGUgPT09ICdoaWRkZW4nXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGhhc01vcmVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRNb3JlICYmIHRoaXMubG9hZE1vcmUuaGFzTW9yZTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZWREYXRhLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGF0YSBzZXR0ZXIuIE11c3QgYmUgYSByZXNwb25zZSBmcm9tIEBjOHkvZGF0YSBvciBhbiBvYnNlcnZhYmxlLlxuICAgKiBZb3UgY2FuIHBhc3MgYW4gb2JzZXJ2YWJsZSB3aXRoIG51bGwgdG8gZXhwbGljaXRseSBjbGVhciB0aGUgbGlzdC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBjOHlGb3JPZihmZXRjaERhdGE6IElSZXN1bHRMaXN0PElJZGVudGlmaWVkPiB8IE9ic2VydmFibGU8SVJlc3VsdExpc3Q8SUlkZW50aWZpZWQ+Pikge1xuICAgIGlmIChmZXRjaERhdGEpIHtcbiAgICAgIHRoaXMub2JzJCA9IChpc09ic2VydmFibGUoZmV0Y2hEYXRhKSA/IGZldGNoRGF0YSA6IG9mKGZldGNoRGF0YSkpLnBpcGUoXG4gICAgICAgIG1hcChyZXN1bHQgPT4ge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGFnaW5nID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeyBwYWdpbmcsIGRhdGEgfSA9IHJlc3VsdDtcbiAgICAgICAgICB0aGlzLnBhZ2luZyA9IHBhZ2luZztcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlIHNldHRlcjpcbiAgICogIC0gYXV0bzogVHJpZXMgdG8gYXV0b21hdGljYWxseSBsb2FkIG1vcmUgZGF0YSAoZGVmYXVsdCBtYXhpbXVtIDEwIGl0ZXJhdGlvbnM7IGNhbiBiZVxuICAgKiAgICAgICAgICBjaGFuZ2Ugd2l0aCBtYXhJdGVyYXRpb25zIHNldHRpbmdzKS5cbiAgICogIC0gc2hvdzogU2hvd3MgYSBsb2FkIG1vcmUgYnV0dG9uIGZvciB0aGUgdXNlciB0byBkZWNpZGVcbiAgICogIC0gbm9uZTogRG9lc24ndCBwZXJmb3JtIGFueSBsb2FkIG1vcmUgYWN0aW9uLlxuICAgKiAgLSBoaWRkZW46IExvYWRzIG1vcmUgZGF0YSBhdXRvbWF0aWNhbGx5IGJ1dCB3aXRoIG5vIHZpc2libGUgYnV0dG9uIGZvciB0aGUgdXNlci5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBjOHlGb3JMb2FkTW9yZSh0eXBlOiBMb2FkTW9yZU1vZGUpIHtcbiAgICB0aGlzLmxvYWRNb3JlTW9kZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHBpcGUgc2V0dGVyIHRvIGF0dGFjaCBhbnkgcnhqcyBwaXBlIHRvIHRoZSBjdXJyZW50IGFuZCBtb3JlIGxvYWRlZCBkYXRhLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGM4eUZvclBpcGUoZGF0YVBpcGUpIHtcbiAgICBpZiAoZGF0YVBpcGUpIHtcbiAgICAgIHRoaXMuZGF0YVBpcGUgPSBkYXRhUGlwZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSB0ZW1wbGF0ZSB0byB1c2UgaWYgbm8gZGF0YSBpcyBmb3VuZCBhdCBhbGwgKGUuZy4gaWYgeW91IGFwcGx5IGEgZmlsdGVyIHBpcGUpLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGM4eUZvck5vdEZvdW5kKG5vdEZvdW5kVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICB0aGlzLm5vdEZvdW5kVGVtcGxhdGUgPSBub3RGb3VuZFRlbXBsYXRlO1xuICAgIGlmICh0aGlzLmxvYWRNb3JlKSB7XG4gICAgICB0aGlzLmxvYWRNb3JlLm5vTW9yZURhdGFIaW50ID0gbm90Rm91bmRUZW1wbGF0ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVycyBvZiBpdGVyYXRpb25zIHRvIGNhbGwgZGF0YSBmcm9tIHRoZSBhcGkuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgYzh5Rm9yTWF4SXRlcmF0aW9ucyhtYXhJdGVyYXRpb25zOiBudW1iZXIpIHtcbiAgICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBtYXhJdGVyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgY3VzdG9tIGxvYWRpbmcgY29tcG9uZW50LlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGM4eUZvckxvYWRpbmdUZW1wbGF0ZShsb2FkaW5nVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICB0aGlzLmxvYWRpbmdUZW1wbGF0ZSA9IGxvYWRpbmdUZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5leHQgdGV4dCBsYWJlbC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBjOHlGb3JMb2FkTmV4dExhYmVsKGxvYWROZXh0TGFiZWw6IHN0cmluZykge1xuICAgIHRoaXMubG9hZE5leHRMYWJlbCA9IGxvYWROZXh0TGFiZWw7XG4gIH1cblxuICAvKipcbiAgICogQSBSZWFsdGltZVNlcnZpY2UgaW5zdGFuY2UuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgYzh5Rm9yUmVhbHRpbWUoc291cmNlOiBSZWFsdGltZVNlcnZpY2U8YW55Pikge1xuICAgIHRoaXMucmVhbHRpbWUgPSBzb3VyY2U7XG4gIH1cblxuICAvKipcbiAgICogQSBjb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBjb21wYXJpbmcgbGlzdCBpdGVtcy4gVXNlZCB0byBkZXRlcm1pbmVcbiAgICogdGhlIHBvc2l0aW9uIGF0IHdoaWNoIGEgbmV3IGVsZW1lbnQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGM4eUZvckNvbXBhcmF0b3IoY29tcGFyYXRvcjogKGl0ZW1BOiBvYmplY3QsIGl0ZW1COiBvYmplY3QpID0+IG51bWJlcikge1xuICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRwbDogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcml2YXRlIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcml2YXRlIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICkge31cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZVJlYWx0aW1lKCk7XG4gIH1cblxuICBwcml2YXRlIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5vYnMkICYmIChjaGFuZ2VzLmM4eUZvclBpcGUgfHwgY2hhbmdlcy5jOHlGb3JPZikpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmVQYWdpbmcoKTtcblxuICAgICAgLy8gb25seSByZS1yZW5kZXJpbmcgIG9uIGZpbHRlcmluZyBpZiBhbGwgZGF0YSBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgLy8gZnJvbSB0aGUgYmFja2VuZFxuICAgICAgY29uc3QgcmVSZW5kZXIgPSAhdGhpcy5oYXNNb3JlRGF0YSAmJiAhIWNoYW5nZXMuYzh5Rm9yUGlwZSAmJiAhY2hhbmdlcy5jOHlGb3JPZjtcblxuICAgICAgaWYgKHJlUmVuZGVyKSB7XG4gICAgICAgIHRoaXMub2JzJCA9IG9mKHRoaXMuY2FjaGVkRGF0YSk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhZ2luZ1N1YiA9IHRoaXMub2JzJFxuICAgICAgICAucGlwZShcbiAgICAgICAgICB0YXAoZGF0YSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlUmVuZGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgICAucGlwZShzcmMgPT4gdGhpcy5kYXRhUGlwZShzcmMpKVxuICAgICAgICAuc3Vic2NyaWJlKChkYXRhOiBbXSkgPT4ge1xuICAgICAgICAgIHRoaXMucmVuZGVyKGRhdGEsIHJlUmVuZGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnVuc3Vic2NyaWJlUGFnaW5nKCk7XG4gICAgdGhpcy51bnN1YnNjcmliZSQubmV4dCgpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUkLmNvbXBsZXRlKCk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVJlYWx0aW1lKCkge1xuICAgIGlmICh0aGlzLnJlYWx0aW1lKSB7XG4gICAgICB0aGlzLnJlYWx0aW1lXG4gICAgICAgIC5vbkNyZWF0ZSQoKVxuICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy51bnN1YnNjcmliZSQpKVxuICAgICAgICAuc3Vic2NyaWJlKGl0ZW0gPT4gdGhpcy5pbnNlcnQoaXRlbSkpO1xuICAgICAgdGhpcy5yZWFsdGltZVxuICAgICAgICAub25VcGRhdGUkKClcbiAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJzY3JpYmUkKSlcbiAgICAgICAgLnN1YnNjcmliZShpdGVtID0+IHRoaXMudXBkYXRlKGl0ZW0pKTtcbiAgICAgIHRoaXMucmVhbHRpbWVcbiAgICAgICAgLm9uRGVsZXRlJCgpXG4gICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLnVuc3Vic2NyaWJlJCkpXG4gICAgICAgIC5zdWJzY3JpYmUoaWQgPT4gdGhpcy5yZW1vdmUoY29lcmNlTnVtYmVyUHJvcGVydHkoaWQpKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXIoZGF0YSwgcmVSZW5kZXIgPSBmYWxzZSk6IHZvaWQge1xuICAgIHRoaXMudmNyLmNsZWFyKCk7XG5cbiAgICBkYXRhLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAkaW1wbGljaXQ6IGl0ZW0sXG4gICAgICAgIGluZGV4LFxuICAgICAgICBsZW5ndGg6IHRoaXMubGVuZ3RoLFxuICAgICAgICBoYXNNb3JlOiB0aGlzLmhhc01vcmVEYXRhLFxuICAgICAgICBsb2FkTW9yZUNvbXBvbmVudDogdGhpcy5sb2FkTW9yZVxuICAgICAgfTtcbiAgICAgIHRoaXMudmNyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRwbCwgY29udGV4dCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5zaG91bGRVc2VMb2FkTW9yZUJ1dHRvbikge1xuICAgICAgdGhpcy5sb2FkTW9yZSA9IHRoaXMuY3JlYXRlTG9hZE1vcmVCdXR0b25Db21wb25lbnQocmVSZW5kZXIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXBwZW5kKGRhdGEpIHtcbiAgICBkYXRhLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuc2hvdWxkVXNlTG9hZE1vcmVCdXR0b24gPyB0aGlzLnZjci5sZW5ndGggLSAxIDogdGhpcy52Y3IubGVuZ3RoO1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgJGltcGxpY2l0OiBpdGVtLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgbGVuZ3RoOiB0aGlzLmxlbmd0aCxcbiAgICAgICAgaGFzTW9yZTogdGhpcy5oYXNNb3JlRGF0YSxcbiAgICAgICAgbG9hZE1vcmVDb21wb25lbnQ6IHRoaXMubG9hZE1vcmVcbiAgICAgIH07XG4gICAgICB0aGlzLnZjci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50cGwsIGNvbnRleHQsIGluZGV4KTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgbG9hZE1vcmVEYXRhKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmFwcGVuZChkYXRhKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUxvYWRNb3JlQnV0dG9uQ29tcG9uZW50KHJlUmVuZGVyKSB7XG4gICAgY29uc3QgY29tcG9uZW50RmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxcbiAgICAgIGFueVxuICAgID4gPSB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShMb2FkTW9yZUNvbXBvbmVudCk7XG4gICAgY29uc3QgY29tcG9uZW50UmVmID0gdGhpcy52Y3IuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudEZhY3RvcnkpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gY29tcG9uZW50UmVmLmluc3RhbmNlIGFzIExvYWRNb3JlQ29tcG9uZW50O1xuICAgIGluc3RhbmNlLnBhZ2luZyA9IHRoaXMucGFnaW5nO1xuICAgIGluc3RhbmNlLnVzZUludGVyc2VjdGlvbiA9IHRoaXMubG9hZE1vcmVNb2RlID09PSAnYXV0bycgfHwgdGhpcy5sb2FkTW9yZU1vZGUgPT09ICdoaWRkZW4nO1xuICAgIGluc3RhbmNlLmhpZGRlbiA9IHRoaXMubG9hZE1vcmVNb2RlID09PSAnaGlkZGVuJztcbiAgICBpbnN0YW5jZS5tYXhJdGVyYXRpb25zID0gdGhpcy5tYXhJdGVyYXRpb25zO1xuICAgIGluc3RhbmNlLm5vTW9yZURhdGFIaW50ID0gdGhpcy5ub3RGb3VuZFRlbXBsYXRlO1xuICAgIGluc3RhbmNlLmxvYWRpbmdUZW1wbGF0ZSA9IHRoaXMubG9hZGluZ1RlbXBsYXRlO1xuICAgIGluc3RhbmNlLmxvYWROZXh0TGFiZWwgPSB0aGlzLmxvYWROZXh0TGFiZWw7XG4gICAgdGhpcy5wYWdpbmdTdWIgPSBpbnN0YW5jZS5vbkxvYWRcbiAgICAgIC5waXBlKFxuICAgICAgICBtYXAoKGRhdGE6IFtdKSA9PiB0aGlzLmNoZWNrRm9yRHVwbGljYXRlcyhkYXRhKSksXG4gICAgICAgIHRhcCgoZGF0YTogW10pID0+IHtcbiAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSB0aGlzLmNhY2hlZERhdGEuY29uY2F0KGRhdGEpO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgLnBpcGUoc3JjID0+IHRoaXMuZGF0YVBpcGUoc3JjKSlcbiAgICAgIC5zdWJzY3JpYmUoZGF0YSA9PiB0aGlzLmxvYWRNb3JlRGF0YShkYXRhKSk7XG4gICAgaWYgKHJlUmVuZGVyKSB7XG4gICAgICBhc3NpZ24oaW5zdGFuY2UsIHRoaXMubG9hZE1vcmUpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBwcml2YXRlIGluc2VydChpdGVtKSB7XG4gICAgbGV0IGluZGV4OiBudW1iZXIgPSAwO1xuXG4gICAgaWYgKHRoaXMuY29tcGFyYXRvciAmJiB0aGlzLmNhY2hlZERhdGEubGVuZ3RoKSB7XG4gICAgICBsZXQgY29tcGFyaXNpb25SZXN1bHQ6IG51bWJlcjtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3QgdmlldzogRW1iZWRkZWRWaWV3UmVmPGFueT4gPSB0aGlzLnZjci5nZXQoaW5kZXgpIGFzIEVtYmVkZGVkVmlld1JlZjxhbnk+O1xuICAgICAgICBjb25zdCBpdGVtQiA9IGdldCh2aWV3LCAnY29udGV4dC4kaW1wbGljaXQnKTtcbiAgICAgICAgY29tcGFyaXNpb25SZXN1bHQgPSBpdGVtICYmIGl0ZW1CID8gdGhpcy5jb21wYXJhdG9yKGl0ZW0sIGl0ZW1CKSA6IDA7XG4gICAgICAgIGlmIChjb21wYXJpc2lvblJlc3VsdCA8PSAwKSB7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoY29tcGFyaXNpb25SZXN1bHQgPD0gMCAmJiBpbmRleCA8IHRoaXMuY2FjaGVkRGF0YS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCBhcHBlbmQgZWxlbWVudHMgYWZ0ZXIgdGhlIGxhc3Qgb25lIGN1cnJlbnRseSBsb2FkZWQsXG4gICAgLy8gYXMgaXQgbWF5IGJlbG9uZyBmdXJ0aGVyIGRvd24gdGhlcmUgb24gdGhlIGxpc3QgYW5kIHdpbGxcbiAgICAvLyBiZSBldmVudHVhbGx5IGxvYWRlZCB3aXRoIG9uZSBvZiB0aGUgbmV4dCBwYWdlcy5cbiAgICBpZiAoaW5kZXggPCB0aGlzLmNhY2hlZERhdGEubGVuZ3RoIHx8IHRoaXMuY2FjaGVkRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICRpbXBsaWNpdDogaXRlbSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgIGhhc01vcmU6IHRoaXMuaGFzTW9yZURhdGFcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuY2FjaGVkRGF0YS5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuICAgICAgY29uc3Qgdmlld1JlZjogVmlld1JlZiA9IHRoaXMudHBsLmNyZWF0ZUVtYmVkZGVkVmlldyhjb250ZXh0KTtcbiAgICAgIHRoaXMudmNyLmluc2VydCh2aWV3UmVmLCBpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGUodXBkYXRlZEl0ZW0pIHtcbiAgICB0aGlzLmZvck1hdGNoaW5nRW1iZWRkZWRWaWV3UmVmKFxuICAgICAgKGl0ZW06IElJZGVudGlmaWVkKSA9PiBpdGVtICYmIHVwZGF0ZWRJdGVtICYmIGl0ZW0uaWQgPT09IHVwZGF0ZWRJdGVtLmlkLFxuICAgICAgKHZpZXc6IEVtYmVkZGVkVmlld1JlZjxhbnk+KSA9PiB7XG4gICAgICAgIHZpZXcuY29udGV4dC4kaW1wbGljaXQgPSB1cGRhdGVkSXRlbTtcbiAgICAgICAgdmlldy5tYXJrRm9yQ2hlY2soKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmUoaWRUb1JlbW92ZSkge1xuICAgIHRoaXMuZm9yTWF0Y2hpbmdFbWJlZGRlZFZpZXdSZWYoXG4gICAgICAoaXRlbTogSUlkZW50aWZpZWQpID0+IGl0ZW0gJiYgY29lcmNlTnVtYmVyUHJvcGVydHkoaXRlbS5pZCwgTmFOKSA9PT0gaWRUb1JlbW92ZSxcbiAgICAgICh2aWV3OiBFbWJlZGRlZFZpZXdSZWY8YW55PikgPT4gdmlldy5kZXN0cm95KClcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBmb3JNYXRjaGluZ0VtYmVkZGVkVmlld1JlZihcbiAgICBmaWx0ZXI6IChpdGVtOiBJSWRlbnRpZmllZCkgPT4gYm9vbGVhbixcbiAgICBjYWxsYmFjazogKHZpZXc6IEVtYmVkZGVkVmlld1JlZjxhbnk+KSA9PiB2b2lkXG4gICkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52Y3IubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZpZXc6IEVtYmVkZGVkVmlld1JlZjxhbnk+ID0gdGhpcy52Y3IuZ2V0KGkpIGFzIEVtYmVkZGVkVmlld1JlZjxhbnk+O1xuICAgICAgY29uc3QgaXRlbTogSUlkZW50aWZpZWQgPSBnZXQodmlldywgJ2NvbnRleHQuJGltcGxpY2l0Jyk7XG4gICAgICBpZiAoZmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgIGNhbGxiYWNrKHZpZXcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tGb3JEdXBsaWNhdGVzKGRhdGE6IElJZGVudGlmaWVkW10pOiBJSWRlbnRpZmllZFtdIHtcbiAgICByZXR1cm4gdGhpcy5yZWFsdGltZVxuICAgICAgPyBkYXRhLmZpbHRlcihpdGVtID0+ICF0aGlzLmNhY2hlZERhdGEuc29tZShjYWNoZWQgPT4gY2FjaGVkLmlkID09PSBpdGVtLmlkKSlcbiAgICAgIDogZGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgdW5zdWJzY3JpYmVQYWdpbmcoKSB7XG4gICAgaWYgKHRoaXMucGFnaW5nU3ViKSB7XG4gICAgICB0aGlzLnBhZ2luZ1N1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIl19