import * as tslib_1 from "tslib";
import { Injectable, InjectionToken, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { BehaviorSubject, Subject } from 'rxjs';
import { map, shareReplay } from 'rxjs/operators';
import { fromTrigger, sortByPriority, stateToFactory } from '../common/extension-hooks';
import { StateService } from '../common/state-service.abstract';
import { NavigatorNodeRoot } from './navigator-node-root';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
/**
 * A hook to use for Multi Provider extension.
 */
export const HOOK_NAVIGATOR_NODES = new InjectionToken('NavigatorNodesFactory');
/**
 * A service which defines the navigator.
 */
let NavigatorService = class NavigatorService extends StateService {
    constructor(injector, router) {
        super();
        this.injector = injector;
        this.router = router;
        /**
         * Refresh the extension factories subject.
         * @readonly
         */
        this.refreshTrigger = new Subject();
        /**
         * @ignore
         */
        this.state$ = new BehaviorSubject(new Set());
        /**
         * Indicates whether the menu entry associated with the given URL should be expanded.
         */
        this.firstUrl = true;
        const rootNode = new NavigatorNodeRoot();
        this.items$ = fromTrigger(router, this.refreshTrigger, [
            () => this.injector.get(HOOK_NAVIGATOR_NODES, []),
            stateToFactory(this.state$)
        ]).pipe(map((nodes) => {
            const noParent = nodes.filter(node => !node.parent);
            const withParent = nodes.filter(node => node.parent);
            // Based on the sortedNodes array, the nodes are sequentially created.
            // Nodes sorting is done in two steps to have the top-level nodes first.
            // This way, by the time we are adding a child node, the parent node is already present.
            const sortedNodes = sortByPriority(noParent).concat(sortByPriority(withParent));
            rootNode.empty();
            sortedNodes.forEach(node => rootNode.addRoot(node));
            return rootNode.children;
        }), shareReplay(1));
    }
    /**
     * Checks whenever a navigator entry associated with the given URL should be expanded.
     * @param {NavigatorNode} node Navigator node.
     */
    openOnFirstUrl(node) {
        if (this.firstUrl && !!node.path) {
            return (this.router.isActive(node.path, node.routerLinkExact) || node.openOnStart(this.router.url));
        }
        return false;
    }
    /**
     * Returns the current state.
     * @readonly
     * @returns The current set of actions.
     */
    get state() {
        return this.state$.value;
    }
    /**
     * Refresh the extension factories.
     */
    refresh() {
        this.refreshTrigger.next(1);
    }
    /**
     * Adds a new node to the navigator.
     * @param {NavigatorNode} node Navigator node to add.
     */
    add(node) {
        this.state.add(node);
        this.emitNewState();
    }
    /**
     * Removes a node from the navigator.
     * @param {NavigatorNode} node Navigator node to remove.
     */
    remove(node) {
        this.state.delete(node);
        this.emitNewState();
    }
};
NavigatorService.ctorParameters = () => [
    { type: Injector },
    { type: Router }
];
NavigatorService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function NavigatorService_Factory() { return new NavigatorService(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.Router)); }, token: NavigatorService, providedIn: "root" });
NavigatorService = tslib_1.__decorate([
    Injectable({
        providedIn: 'root'
    })
], NavigatorService);
export { NavigatorService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdG9yLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYzh5L25neC1jb21wb25lbnRzLyIsInNvdXJjZXMiOlsiY29yZS9uYXZpZ2F0b3IvbmF2aWdhdG9yLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFFLGVBQWUsRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRCxPQUFPLEVBRUwsV0FBVyxFQUNYLGNBQWMsRUFDZCxjQUFjLEVBQ2YsTUFBTSwyQkFBMkIsQ0FBQztBQUNuQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFHaEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7OztBQUUxRDs7R0FFRztBQUNILE1BQU0sQ0FBQyxNQUFNLG9CQUFvQixHQUFHLElBQUksY0FBYyxDQUFDLHVCQUF1QixDQUFDLENBQUM7QUFFaEY7O0dBRUc7QUFJSCxJQUFhLGdCQUFnQixHQUE3QixNQUFhLGdCQUFpQixTQUFRLFlBQVk7SUF1QmhELFlBQW9CLFFBQWtCLEVBQVUsTUFBYztRQUM1RCxLQUFLLEVBQUUsQ0FBQztRQURVLGFBQVEsR0FBUixRQUFRLENBQVU7UUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBaEI5RDs7O1dBR0c7UUFDTSxtQkFBYyxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7UUFFeEM7O1dBRUc7UUFDTSxXQUFNLEdBQUcsSUFBSSxlQUFlLENBQXFCLElBQUksR0FBRyxFQUFpQixDQUFDLENBQUM7UUFFcEY7O1dBRUc7UUFDSCxhQUFRLEdBQUcsSUFBSSxDQUFDO1FBSWQsTUFBTSxRQUFRLEdBQUcsSUFBSSxpQkFBaUIsRUFBRSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3JELEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLG9CQUFvQixFQUFFLEVBQUUsQ0FBQztZQUNqRCxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUM1QixDQUFDLENBQUMsSUFBSSxDQUNMLEdBQUcsQ0FBQyxDQUFDLEtBQW1DLEVBQUUsRUFBRTtZQUMxQyxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDcEQsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUVyRCxzRUFBc0U7WUFDdEUsd0VBQXdFO1lBQ3hFLHdGQUF3RjtZQUN4RixNQUFNLFdBQVcsR0FBRyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2hGLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNqQixXQUFXLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ3BELE9BQU8sUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUMzQixDQUFDLENBQUMsRUFDRixXQUFXLENBQUMsQ0FBQyxDQUFDLENBQ2YsQ0FBQztJQUNKLENBQUM7SUFFRDs7O09BR0c7SUFDSCxjQUFjLENBQUMsSUFBbUI7UUFDaEMsSUFBSSxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2hDLE9BQU8sQ0FDTCxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQzNGLENBQUM7U0FDSDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxJQUFJLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7T0FFRztJQUNILE9BQU87UUFDTCxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsR0FBRyxDQUFDLElBQW1CO1FBQ3JCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsTUFBTSxDQUFDLElBQW1CO1FBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN0QixDQUFDO0NBQ0YsQ0FBQTs7WUFyRStCLFFBQVE7WUFBa0IsTUFBTTs7O0FBdkJuRCxnQkFBZ0I7SUFINUIsVUFBVSxDQUFDO1FBQ1YsVUFBVSxFQUFFLE1BQU07S0FDbkIsQ0FBQztHQUNXLGdCQUFnQixDQTRGNUI7U0E1RlksZ0JBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIHNoYXJlUmVwbGF5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgRXh0ZW5zaW9uUG9pbnQsXG4gIGZyb21UcmlnZ2VyLFxuICBzb3J0QnlQcmlvcml0eSxcbiAgc3RhdGVUb0ZhY3Rvcnlcbn0gZnJvbSAnLi4vY29tbW9uL2V4dGVuc2lvbi1ob29rcyc7XG5pbXBvcnQgeyBTdGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vc3RhdGUtc2VydmljZS5hYnN0cmFjdCc7XG5pbXBvcnQgeyBOYXZpZ2F0b3JOb2RlIH0gZnJvbSAnLi9uYXZpZ2F0b3Itbm9kZSc7XG5pbXBvcnQgeyBOYXZpZ2F0b3JOb2RlRGF0YSB9IGZyb20gJy4vbmF2aWdhdG9yLW5vZGUtZGF0YSc7XG5pbXBvcnQgeyBOYXZpZ2F0b3JOb2RlUm9vdCB9IGZyb20gJy4vbmF2aWdhdG9yLW5vZGUtcm9vdCc7XG5cbi8qKlxuICogQSBob29rIHRvIHVzZSBmb3IgTXVsdGkgUHJvdmlkZXIgZXh0ZW5zaW9uLlxuICovXG5leHBvcnQgY29uc3QgSE9PS19OQVZJR0FUT1JfTk9ERVMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05hdmlnYXRvck5vZGVzRmFjdG9yeScpO1xuXG4vKipcbiAqIEEgc2VydmljZSB3aGljaCBkZWZpbmVzIHRoZSBuYXZpZ2F0b3IuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRvclNlcnZpY2UgZXh0ZW5kcyBTdGF0ZVNlcnZpY2UgaW1wbGVtZW50cyBFeHRlbnNpb25Qb2ludDxOYXZpZ2F0b3JOb2RlPiB7XG4gIC8qKlxuICAgKiBOYXZpZ2F0b3IgbWVudSBpdGVtcyBvYnNlcnZhYmxlLiBJdCBlbWl0cyB0aGUgY3VycmVudCBsaXN0IG9mIG5vZGVzIGluIHRoZSBuYXZpZ2F0b3IuXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgaXRlbXMkOiBPYnNlcnZhYmxlPE5hdmlnYXRvck5vZGVbXT47XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGV4dGVuc2lvbiBmYWN0b3JpZXMgc3ViamVjdC5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICByZWFkb25seSByZWZyZXNoVHJpZ2dlciA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHJlYWRvbmx5IHN0YXRlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8U2V0PE5hdmlnYXRvck5vZGU+PihuZXcgU2V0PE5hdmlnYXRvck5vZGU+KCkpO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbWVudSBlbnRyeSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIFVSTCBzaG91bGQgYmUgZXhwYW5kZWQuXG4gICAqL1xuICBmaXJzdFVybCA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHJvb3ROb2RlID0gbmV3IE5hdmlnYXRvck5vZGVSb290KCk7XG4gICAgdGhpcy5pdGVtcyQgPSBmcm9tVHJpZ2dlcihyb3V0ZXIsIHRoaXMucmVmcmVzaFRyaWdnZXIsIFtcbiAgICAgICgpID0+IHRoaXMuaW5qZWN0b3IuZ2V0KEhPT0tfTkFWSUdBVE9SX05PREVTLCBbXSksXG4gICAgICBzdGF0ZVRvRmFjdG9yeSh0aGlzLnN0YXRlJClcbiAgICBdKS5waXBlKFxuICAgICAgbWFwKChub2RlczogUGFydGlhbDxOYXZpZ2F0b3JOb2RlRGF0YVtdPikgPT4ge1xuICAgICAgICBjb25zdCBub1BhcmVudCA9IG5vZGVzLmZpbHRlcihub2RlID0+ICFub2RlLnBhcmVudCk7XG4gICAgICAgIGNvbnN0IHdpdGhQYXJlbnQgPSBub2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLnBhcmVudCk7XG5cbiAgICAgICAgLy8gQmFzZWQgb24gdGhlIHNvcnRlZE5vZGVzIGFycmF5LCB0aGUgbm9kZXMgYXJlIHNlcXVlbnRpYWxseSBjcmVhdGVkLlxuICAgICAgICAvLyBOb2RlcyBzb3J0aW5nIGlzIGRvbmUgaW4gdHdvIHN0ZXBzIHRvIGhhdmUgdGhlIHRvcC1sZXZlbCBub2RlcyBmaXJzdC5cbiAgICAgICAgLy8gVGhpcyB3YXksIGJ5IHRoZSB0aW1lIHdlIGFyZSBhZGRpbmcgYSBjaGlsZCBub2RlLCB0aGUgcGFyZW50IG5vZGUgaXMgYWxyZWFkeSBwcmVzZW50LlxuICAgICAgICBjb25zdCBzb3J0ZWROb2RlcyA9IHNvcnRCeVByaW9yaXR5KG5vUGFyZW50KS5jb25jYXQoc29ydEJ5UHJpb3JpdHkod2l0aFBhcmVudCkpO1xuICAgICAgICByb290Tm9kZS5lbXB0eSgpO1xuICAgICAgICBzb3J0ZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4gcm9vdE5vZGUuYWRkUm9vdChub2RlKSk7XG4gICAgICAgIHJldHVybiByb290Tm9kZS5jaGlsZHJlbjtcbiAgICAgIH0pLFxuICAgICAgc2hhcmVSZXBsYXkoMSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGVuZXZlciBhIG5hdmlnYXRvciBlbnRyeSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIFVSTCBzaG91bGQgYmUgZXhwYW5kZWQuXG4gICAqIEBwYXJhbSB7TmF2aWdhdG9yTm9kZX0gbm9kZSBOYXZpZ2F0b3Igbm9kZS5cbiAgICovXG4gIG9wZW5PbkZpcnN0VXJsKG5vZGU6IE5hdmlnYXRvck5vZGUpIHtcbiAgICBpZiAodGhpcy5maXJzdFVybCAmJiAhIW5vZGUucGF0aCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5yb3V0ZXIuaXNBY3RpdmUobm9kZS5wYXRoLCBub2RlLnJvdXRlckxpbmtFeGFjdCkgfHwgbm9kZS5vcGVuT25TdGFydCh0aGlzLnJvdXRlci51cmwpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHNldCBvZiBhY3Rpb25zLlxuICAgKi9cbiAgZ2V0IHN0YXRlKCk6IFNldDxOYXZpZ2F0b3JOb2RlPiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUkLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGV4dGVuc2lvbiBmYWN0b3JpZXMuXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMucmVmcmVzaFRyaWdnZXIubmV4dCgxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IG5vZGUgdG8gdGhlIG5hdmlnYXRvci5cbiAgICogQHBhcmFtIHtOYXZpZ2F0b3JOb2RlfSBub2RlIE5hdmlnYXRvciBub2RlIHRvIGFkZC5cbiAgICovXG4gIGFkZChub2RlOiBOYXZpZ2F0b3JOb2RlKSB7XG4gICAgdGhpcy5zdGF0ZS5hZGQobm9kZSk7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoZSBuYXZpZ2F0b3IuXG4gICAqIEBwYXJhbSB7TmF2aWdhdG9yTm9kZX0gbm9kZSBOYXZpZ2F0b3Igbm9kZSB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmUobm9kZTogTmF2aWdhdG9yTm9kZSkge1xuICAgIHRoaXMuc3RhdGUuZGVsZXRlKG5vZGUpO1xuICAgIHRoaXMuZW1pdE5ld1N0YXRlKCk7XG4gIH1cbn1cbiJdfQ==