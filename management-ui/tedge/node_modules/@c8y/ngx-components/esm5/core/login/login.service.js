import * as tslib_1 from "tslib";
import { Injectable, Optional } from '@angular/core';
import { BasicAuth, CookieAuth, FetchClient, IAuthentication, ICredentials, ITenantLoginOption, TenantLoginOptionType, Realtime, TenantService, UserService } from '@c8y/client';
import { AppStateService } from '../common/ui-state.service';
import { AlertService } from '../alert/alert.service';
import { gettext } from '../i18n/gettext';
import { ApiService } from '@c8y/ngx-components/api';
import { switchMap } from 'rxjs/operators';
import { EMPTY } from 'rxjs';
import { LocationStrategy } from '@angular/common';
import { get, isString } from 'lodash-es';
/**
 * Service to manage the login.
 */
var LoginService = /** @class */ (function () {
    function LoginService(client, basicAuth, cookieAuth, ui, user, tenant, realtime, alert, api, location) {
        this.client = client;
        this.basicAuth = basicAuth;
        this.cookieAuth = cookieAuth;
        this.ui = ui;
        this.user = user;
        this.tenant = tenant;
        this.realtime = realtime;
        this.alert = alert;
        this.api = api;
        this.location = location;
        this.rememberMe = false;
        this.TOKEN_KEY = '_tcy8';
        this.TFATOKEN_KEY = 'TFAToken';
        this.isFirstLogin = true;
        this.GREEN_MIN_LENGTH_DEFAULT = 8;
        // tslint:disable:max-line-length
        this.ERROR_MESSAGES = {
            minlength: gettext('Password must have at least 8 characters and no more than 32.'),
            password_missmatch: gettext('Password confirmation does not match.'),
            maxlength: gettext('Password must have at least 8 characters and no more than 32.'),
            password_strength: gettext('Your password is not strong enough. Please include numbers, lower and upper case characters'),
            remote_error: gettext('Server error occurred.'),
            email: gettext('Invalid email address.'),
            password_change: gettext('Your password is expired. Please set a new password.'),
            password_reset_token_expired: gettext('Password reset link expired. Please enter your email address to receive a new one.'),
            tfa_pin_invalid: gettext('The code you entered is invalid. Please try again.'),
            pattern_phonenumber: gettext('Invalid phone number format. Only digits, spaces, slashes ("/") and dashes ("-") allowed.'),
            pattern_newPassword: gettext('Password must have at least 8 characters and no more than 32 and can only contain letters, numbers and following symbols: `~!@#$%^&*()_|+-=?;:\'",.<>{}[]\\/'),
            international_number_required: gettext('International phone number required, in the format +49 9 876 543 210.'),
            phone_number_error: gettext('Could not update phone number.'),
            pinAlreadySent: gettext('The verification code was already sent. For a new verification code, please click on the link above.'),
            passwordConfirm: gettext('Password confirmation does not match.'),
            tfaExpired: gettext('Two-factor authentication token expired.')
        };
        // tslint:enable:max-line-length
        this.SUCCESS_MESSAGES = {
            password_changed: gettext('Password changed. You can now log in using new password.'),
            password_reset_requested: gettext('Password reset request has been sent. Please check your email.'),
            resend_sms: gettext('Verification code SMS resent.'),
            send_sms: gettext('Verification code SMS sent.')
        };
        this.passwordStrengthSetting = {
            enforcePasswordStrength: false,
            greenMinLength: this.GREEN_MIN_LENGTH_DEFAULT,
            passwordStrengthValidity: false
        };
        this.loginModeFilters = {
            isOauth2Internal: function (_a) {
                var type = _a.type, visibleOnLoginPage = _a.visibleOnLoginPage;
                return type === TenantLoginOptionType.OAUTH2_INTERNAL && visibleOnLoginPage;
            },
            isBasic: function (_a) {
                var type = _a.type, visibleOnLoginPage = _a.visibleOnLoginPage;
                return type === TenantLoginOptionType.BASIC && visibleOnLoginPage;
            },
            isOauth2: function (_a) {
                var type = _a.type, visibleOnLoginPage = _a.visibleOnLoginPage, grantType = _a.grantType;
                return type === TenantLoginOptionType.OAUTH2 && visibleOnLoginPage && grantType === 'AUTHORIZATION_CODE';
            }
        };
        this.localhostRegExp = new RegExp('localhost');
        this.localhostIpRegExp = new RegExp('127.0.0.1');
        this.showTenantRegExp = new RegExp('showTenant');
        this.autoLogout();
        this.initLoginOptions();
    }
    /**
     * Returns the current tenant.
     * @return The tenant name.
     */
    LoginService.prototype.getTenant = function () {
        return this.client.tenant;
    };
    LoginService.prototype.initLoginOptions = function () {
        var loginOptions = this.ui.state.loginOptions || [];
        this.loginMode = loginOptions.find(this.loginModeFilters.isOauth2Internal) ||
            loginOptions.find(this.loginModeFilters.isBasic) ||
            loginOptions.find(this.loginModeFilters.isOauth2) || { type: TenantLoginOptionType.BASIC };
        this.oauthOptions = loginOptions.find(this.loginModeFilters.isOauth2) || {};
    };
    LoginService.prototype.redirectToOauth = function () {
        var initRequest = this.oauthOptions.initRequest;
        var fullPath = (this.location ? this.location._platformLocation : window).location
            .href;
        var redirectUrl = encodeURIComponent(fullPath);
        var originUriParam = (initRequest.includes('?') ? '&' : '?') + "originUri=" + redirectUrl;
        window.location.href = "" + initRequest + originUriParam;
    };
    LoginService.prototype.autoLogout = function () {
        var _this = this;
        var errorPattern = /invalid\scredentials.*pin.*generate/i;
        var isTfaExpired = function (data) {
            return data && typeof data.message === 'string' && errorPattern.test(data.message);
        };
        this.ui.currentUser
            .pipe(switchMap(function (u) {
            return u ? _this.api.hookResponse(function (_a) {
                var response = _a.response;
                return response.status === 401;
            }) : EMPTY;
        }))
            .subscribe(function (apiCall) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var response, willLogout, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        response = apiCall.response;
                        willLogout = false;
                        if (!isTfaExpired(response.data)) return [3 /*break*/, 1];
                        willLogout = true;
                        return [3 /*break*/, 3];
                    case 1:
                        if (!(typeof response.json === 'function')) return [3 /*break*/, 3];
                        return [4 /*yield*/, response.clone().json()];
                    case 2:
                        data = _a.sent();
                        if (isTfaExpired(data)) {
                            willLogout = true;
                        }
                        _a.label = 3;
                    case 3:
                        if (willLogout) {
                            this.logout(false);
                            setTimeout(function () { return _this.alert.danger(_this.ERROR_MESSAGES.tfaExpired); }, 500);
                        }
                        return [2 /*return*/];
                }
            });
        }); });
    };
    /**
     * Gets the minimal number of characters that a password should have to be considered a “green” strong one.
     * @return The min length for password or default value.
     */
    LoginService.prototype.getGreenMinLength = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var greenMinLength;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getBasicAuthLoginOption()];
                    case 1:
                        greenMinLength = ((_a.sent()) || { greenMinLength: null }).greenMinLength;
                        this.passwordStrengthSetting.greenMinLength = greenMinLength || this.GREEN_MIN_LENGTH_DEFAULT;
                        return [2 /*return*/, this.passwordStrengthSetting.greenMinLength];
                }
            });
        });
    };
    /**
     * Checks if password strength is enforced for system
     * by retrieving value of `enforceStrength` property from loginOptions response
     * @param refresh boolean used to refresh the app state where result of loginOptions response is stored.
     * If false, it takes value from memory,
     * if true, it refresh the app state value and then retrives data.
     * @return boolean value, true if enforced, false otherwise.
     */
    LoginService.prototype.getEnforcePasswordStrength = function (refresh) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getBasicAuthLoginOption(refresh).then(function (loginOption) {
                        var enforcePasswordStrength = get(loginOption, 'enforceStrength');
                        if (isString(enforcePasswordStrength)) {
                            _this.passwordStrengthSetting.enforcePasswordStrength = enforcePasswordStrength === 'true' ? true : false;
                        }
                        else {
                            _this.passwordStrengthSetting.enforcePasswordStrength = !!enforcePasswordStrength;
                        }
                        return _this.passwordStrengthSetting.enforcePasswordStrength;
                    })];
            });
        });
    };
    /**
     * Checks if password strength is enforced for particular tenant
     * by retrieving value of `strengthValidity` property from loginOptions response
     * @param refresh boolean used to refresh the app state where result of loginOptions response is stored.
     * If false, it takes value from memory,
     * if true, it refresh the app state value and then retrives data.
     * @return boolean value, true if enforced, false otherwise.
     */
    LoginService.prototype.getPasswordStrengthValidity = function (refresh) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getBasicAuthLoginOption(refresh).then(function (loginOption) {
                        var strengthValidity = get(loginOption, 'strengthValidity');
                        if (isString(strengthValidity)) {
                            _this.passwordStrengthSetting.passwordStrengthValidity = strengthValidity === 'true' ? true : false;
                        }
                        else {
                            _this.passwordStrengthSetting.passwordStrengthValidity = !!strengthValidity;
                        }
                        return _this.passwordStrengthSetting.passwordStrengthValidity;
                    })];
            });
        });
    };
    /**
     * Function determines if enforced strength checks should be enabled for current tenant
     * based on properties retrieved from loginOptions
     * @param options object containing specific options:
     *    - {refresh: true} - refreshes values of app state and returns fresh values as result of call
     * @return boolean value, true if strength is enforced for tenant, false otherwise.
     */
    LoginService.prototype.getPasswordStrengthEnforced = function (options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var refresh;
            return tslib_1.__generator(this, function (_a) {
                refresh = options && options.refresh;
                return [2 /*return*/, Promise.all([this.getEnforcePasswordStrength(refresh), this.getPasswordStrengthValidity(refresh)]).then(function (values) {
                        var _a = tslib_1.__read(values, 2), enforcePasswordStrength = _a[0], passwordStrengthValidity = _a[1];
                        return enforcePasswordStrength || passwordStrengthValidity;
                    })];
            });
        });
    };
    /**
     * Clears all backend errors.
     */
    LoginService.prototype.cleanMessages = function () {
        this.alert.clearAll();
    };
    /**
     * Adds a new success message
     * @param successKey The key of the success message as used in SUCCESS_MESSAGES
     */
    LoginService.prototype.addSuccessMessage = function (successKey) {
        var successMessage = this.SUCCESS_MESSAGES[successKey];
        if (successMessage) {
            this.alert.add({
                text: successMessage,
                type: 'success',
                timeout: 0
            });
        }
    };
    /**
     * Returns the current strategy. Defaults to cookie, if a token
     * is found in local or session storage we switch to basic auth.
     * @returns The current auth strategy.
     */
    LoginService.prototype.getAuthStrategy = function () {
        var authStrategy = this.cookieAuth;
        var token = this.getStoredToken();
        var tfa = this.getStoredTfaToken();
        if (token) {
            authStrategy = this.basicAuth;
            this.setCredentials({ token: token, tfa: tfa }, this.basicAuth);
        }
        return authStrategy;
    };
    /**
     * Forces the use of basic auth as strategy with this credentials.
     * @param credentials The credentials to use.
     */
    LoginService.prototype.useBasicAuth = function (credentials) {
        this.setCredentials(credentials, this.basicAuth);
        return this.basicAuth;
    };
    /**
     * Tries to login a user with the given credentials.
     * If successful, the current tenant and user is set. If not an error
     * is thrown. It also verifies if the user is allowed to open the
     * current app.
     * @param auth The authentication strategy used.
     * @param credentials The credentials to try to login.
     */
    LoginService.prototype.login = function (auth, credentials) {
        if (auth === void 0) { auth = this.getAuthStrategy(); }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tenantRes, tenant, userRes, user, supportUserName, token;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.client.setAuth(auth);
                        return [4 /*yield*/, this.tenant.current()];
                    case 1:
                        tenantRes = _a.sent();
                        tenant = tenantRes.data;
                        return [4 /*yield*/, this.switchLoginMode(credentials)];
                    case 2:
                        if (_a.sent()) {
                            auth = this.cookieAuth;
                        }
                        return [4 /*yield*/, this.user.current()];
                    case 3:
                        userRes = _a.sent();
                        user = userRes.data;
                        return [4 /*yield*/, this.verifyAppAccess()];
                    case 4:
                        _a.sent();
                        supportUserName = this.getSupportUserName(credentials);
                        token = this.setCredentials({
                            tenant: tenant.name,
                            user: (supportUserName ? supportUserName + "$" : '') + user.userName
                        }, auth);
                        if (token) {
                            this.storeBasicAuthToken(token);
                        }
                        return [4 /*yield*/, this.authFulfilled(tenant, user, supportUserName)];
                    case 5:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Saves tenant, user and support user info to the app state.
     * @param tenant The current tenant object.
     * @param user The current user object.
     * @param supportUserName The current support user name.
     */
    LoginService.prototype.authFulfilled = function (tenant, user, supportUserName) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!tenant) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.tenant.current()];
                    case 1:
                        data = (_a.sent()).data;
                        tenant = data;
                        this.client.tenant = tenant.name;
                        _a.label = 2;
                    case 2:
                        if (!!user) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.user.current()];
                    case 3:
                        data = (_a.sent()).data;
                        user = data;
                        _a.label = 4;
                    case 4:
                        if (!supportUserName) {
                            supportUserName = null;
                        }
                        this.ui.setUser({ user: user, supportUserName: supportUserName });
                        this.ui.currentTenant.next(tenant);
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Switch the login mode to CookieAuth if the
     * user has configured to use it in loginOptions.
     * @param credentials The credentials for that login
     */
    LoginService.prototype.switchLoginMode = function (credentials) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var isPasswordGrantLogin, res, data, ex_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isPasswordGrantLogin = this.isPasswordGrantLogin(credentials);
                        if (!(isPasswordGrantLogin && credentials)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.generateOauthToken(credentials)];
                    case 1:
                        res = _a.sent();
                        if (!!res.ok) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, res.json()];
                    case 3:
                        data = _a.sent();
                        throw { res: res, data: data };
                    case 4:
                        ex_1 = _a.sent();
                        throw ex_1;
                    case 5:
                        this.client.setAuth(this.cookieAuth);
                        this.cleanLocalStorage();
                        this.basicAuth.logout();
                        _a.label = 6;
                    case 6: return [2 /*return*/, isPasswordGrantLogin];
                }
            });
        });
    };
    LoginService.prototype.generateOauthToken = function (credentials) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var params, urlParams;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.isPasswordGrantLogin(credentials) && credentials)) return [3 /*break*/, 2];
                        params = new URLSearchParams({
                            grant_type: 'PASSWORD',
                            username: credentials.user,
                            password: credentials.password,
                            tfa_code: credentials.tfa
                        });
                        urlParams = new URLSearchParams(this.loginMode.initRequest.split('?').pop());
                        credentials.tenant = urlParams.get('tenant_id');
                        return [4 /*yield*/, this.client.fetch("tenant/oauth?" + urlParams.toString(), {
                                method: 'POST',
                                body: params.toString(),
                                headers: {
                                    'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'
                                }
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    LoginService.prototype.isPasswordGrantLogin = function (credentials) {
        return !!(!this.isSupportUser(credentials) &&
            this.loginMode &&
            this.loginMode.type === TenantLoginOptionType.OAUTH2_INTERNAL);
    };
    /**
     * Verifies if the provided credentials use a support user to log in or not.
     * @param credentials Credentials to check.
     * @returns True if user is a support user.
     */
    LoginService.prototype.isSupportUser = function (credentials) {
        return credentials && credentials.user.includes('$');
    };
    /**
     * Verifies if the tenant input field should be shown
     * or not.
     * @returns If true, show the tenant input.
     */
    LoginService.prototype.showTenant = function () {
        return !this.ui.state.loginOptions || this.isLocal() || this.isShowTenant();
    };
    /**
     * Logs the user out
     * @param reload If set to false, the page will not reload
     */
    LoginService.prototype.logout = function (reload) {
        if (reload === void 0) { reload = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var resData, _a, basicRes, cookieRes, ex_2;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        resData = null;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 4, 5, 6]);
                        return [4 /*yield*/, this.reset()];
                    case 2:
                        _a = tslib_1.__read.apply(void 0, [_b.sent(), 2]), basicRes = _a[0], cookieRes = _a[1];
                        return [4 /*yield*/, cookieRes.json()];
                    case 3:
                        resData = _b.sent();
                        return [3 /*break*/, 6];
                    case 4:
                        ex_2 = _b.sent();
                        this.alert.removeLastDanger();
                        return [3 /*break*/, 6];
                    case 5:
                        if (resData && resData.url) {
                            this.redirect(resData.url);
                        }
                        else if (reload) {
                            this.location.replaceState({}, '', '', '');
                            window.location.reload();
                        }
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Resets the stored auth-data
     */
    LoginService.prototype.reset = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this.cleanLocalStorage();
                this.cleanSessionStorage();
                this.realtime.disconnect();
                this.ui.currentUser.next(null);
                return [2 /*return*/, Promise.all([this.basicAuth.logout(), this.cookieAuth.logout()])];
            });
        });
    };
    /**
     * Saves the TFA token to local or session storage.
     * @param tfaToken The tfa token to save.
     * @param storage The storage to use (local or session).
     */
    LoginService.prototype.saveTFAToken = function (tfaToken, storage) {
        storage.setItem(this.TFATOKEN_KEY, tfaToken);
    };
    /**
     * Request the manifest -> on 401 user has no access to that application
     * and we throw the error up to the login form.
     */
    LoginService.prototype.verifyAppAccess = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var ex_3;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.ui.loadManifest()];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        ex_3 = _a.sent();
                        if (!(ex_3.res && ex_3.res.status === 404 && this.isLocal())) {
                            throw ex_3;
                        }
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the tenant to the client and updates the credentials on the
     * auth strategy.
     * @param credentials The name of the tenant.
     * @param authStrategy The authentication strategy used.
     * @return Returns the token if basic auth, otherwise undefined.
     */
    LoginService.prototype.setCredentials = function (credentials, authStrategy) {
        if (credentials.tenant) {
            this.client.tenant = credentials.tenant;
        }
        // Check if a token is already set (case for support user login)
        // if yes -> we just need to update the user, and reuse the token
        // of the support user.
        // Therefore we need to pass user and tenant, to get
        // just the stored token and nothing else (see BasicAuth.ts:31).
        var token = this.basicAuth.updateCredentials({
            tenant: credentials.tenant,
            user: credentials.user
        });
        var newCredentials = tslib_1.__assign({ token: token }, credentials);
        return authStrategy.updateCredentials(newCredentials);
    };
    /**
     * Verifies if the current user is a developer or not.
     * Running on localhost means development mode.
     */
    LoginService.prototype.isLocal = function () {
        var hostname = window.location.hostname;
        return this.localhostIpRegExp.test(hostname) || this.localhostRegExp.test(hostname);
    };
    /**
     * Save the token to local or session storage.
     * @param token The token to save.
     * @param storage The storage to use (local or session).
     */
    LoginService.prototype.saveToken = function (token, storage) {
        storage.setItem(this.TOKEN_KEY, token);
    };
    LoginService.prototype.storeBasicAuthToken = function (token) {
        this.saveToken(token, sessionStorage);
        if (this.rememberMe) {
            this.saveToken(token, localStorage);
        }
    };
    LoginService.prototype.cleanLocalStorage = function () {
        localStorage.removeItem(this.TOKEN_KEY);
        localStorage.removeItem(this.TFATOKEN_KEY);
    };
    LoginService.prototype.cleanSessionStorage = function () {
        sessionStorage.removeItem(this.TOKEN_KEY);
        sessionStorage.removeItem(this.TFATOKEN_KEY);
    };
    LoginService.prototype.isShowTenant = function () {
        return this.showTenantRegExp.test(window.location.href);
    };
    LoginService.prototype.redirect = function (url) {
        window.location.href = url;
    };
    LoginService.prototype.getBasicAuthLoginOption = function (refresh) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var loginOptions, basicAuthLoginOption;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!refresh) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.ui.refreshLoginOptions()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        loginOptions = this.ui.state.loginOptions || [];
                        basicAuthLoginOption = loginOptions.find(function (_a) {
                            var type = _a.type;
                            return type === 'BASIC';
                        });
                        return [2 /*return*/, Promise.resolve(basicAuthLoginOption)];
                }
            });
        });
    };
    /**
     * Gets support user name from credentials.
     * @param credentials Credentials object (defaults to the stored one).
     * @returns Support user name.
     */
    LoginService.prototype.getSupportUserName = function (credentials) {
        if (credentials === void 0) { credentials = this.getStoredCredentials(); }
        if (!credentials) {
            return null;
        }
        var supportUserName = credentials.user.match(/^(.+\/)?((.+)\$)?(.+)?$/)[3];
        return supportUserName;
    };
    /**
     * Gets credentials object from the stored token.
     * @returns Credentials object.
     */
    LoginService.prototype.getStoredCredentials = function () {
        var token = this.getStoredToken();
        if (!token) {
            return null;
        }
        return this.decodeToken(token);
    };
    /**
     * Gets stored token from local storage or session storage.
     * @returns Stored token.
     */
    LoginService.prototype.getStoredToken = function () {
        return localStorage.getItem(this.TOKEN_KEY) || sessionStorage.getItem(this.TOKEN_KEY);
    };
    /**
     * Gets stored TFA token from local storage or session storage.
     * @returns Stored TFA token.
     */
    LoginService.prototype.getStoredTfaToken = function () {
        return localStorage.getItem(this.TFATOKEN_KEY) || sessionStorage.getItem(this.TFATOKEN_KEY);
    };
    /**
     * Decodes token to credentials object.
     * @param token Token to decode.
     * @returns Credentials object.
     */
    LoginService.prototype.decodeToken = function (token) {
        var decoded = decodeURIComponent(escape(window.atob(token)));
        var split = decoded.match(/(([^/]*)\/)?([^/:]+):(.+)/);
        return {
            tenant: split[2],
            user: split[3],
            password: split[4]
        };
    };
    LoginService.ctorParameters = function () { return [
        { type: FetchClient },
        { type: BasicAuth },
        { type: CookieAuth },
        { type: AppStateService },
        { type: UserService },
        { type: TenantService },
        { type: Realtime },
        { type: AlertService },
        { type: ApiService },
        { type: LocationStrategy, decorators: [{ type: Optional }] }
    ]; };
    LoginService = tslib_1.__decorate([
        Injectable(),
        tslib_1.__param(9, Optional())
    ], LoginService);
    return LoginService;
}());
export { LoginService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9naW4uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BjOHkvbmd4LWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJjb3JlL2xvZ2luL2xvZ2luLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JELE9BQU8sRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFdBQVcsRUFDWCxlQUFlLEVBQ2YsWUFBWSxFQUNaLGtCQUFrQixFQUNsQixxQkFBcUIsRUFDckIsUUFBUSxFQUNSLGFBQWEsRUFDYixXQUFXLEVBQ1osTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzdELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN0RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDMUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3JELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzQyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdCLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBRTFDOztHQUVHO0FBRUg7SUFtRUUsc0JBQ1UsTUFBbUIsRUFDbkIsU0FBb0IsRUFDcEIsVUFBc0IsRUFDdEIsRUFBbUIsRUFDbkIsSUFBaUIsRUFDakIsTUFBcUIsRUFDckIsUUFBa0IsRUFDbEIsS0FBbUIsRUFDbkIsR0FBZSxFQUNILFFBQTBCO1FBVHRDLFdBQU0sR0FBTixNQUFNLENBQWE7UUFDbkIsY0FBUyxHQUFULFNBQVMsQ0FBVztRQUNwQixlQUFVLEdBQVYsVUFBVSxD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Q0wsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDaEIsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDZCxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUNuQixDQUFDO0lBQ0osQ0FBQzs7Z0JBdmZpQixXQUFXO2dCQUNSLFNBQVM7Z0JBQ1IsVUFBVTtnQkFDbEIsZUFBZTtnQkFDYixXQUFXO2dCQUNULGFBQWE7Z0JBQ1gsUUFBUTtnQkFDWCxZQUFZO2dCQUNkLFVBQVU7Z0JBQ08sZ0JBQWdCLHVCQUE3QyxRQUFROztJQTdFQSxZQUFZO1FBRHhCLFVBQVUsRUFBRTtRQThFUixtQkFBQSxRQUFRLEVBQUUsQ0FBQTtPQTdFRixZQUFZLENBNGpCeEI7SUFBRCxtQkFBQztDQUFBLEFBNWpCRCxJQTRqQkM7U0E1akJZLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQmFzaWNBdXRoLFxuICBDb29raWVBdXRoLFxuICBGZXRjaENsaWVudCxcbiAgSUF1dGhlbnRpY2F0aW9uLFxuICBJQ3JlZGVudGlhbHMsXG4gIElUZW5hbnRMb2dpbk9wdGlvbixcbiAgVGVuYW50TG9naW5PcHRpb25UeXBlLFxuICBSZWFsdGltZSxcbiAgVGVuYW50U2VydmljZSxcbiAgVXNlclNlcnZpY2Vcbn0gZnJvbSAnQGM4eS9jbGllbnQnO1xuaW1wb3J0IHsgQXBwU3RhdGVTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3VpLXN0YXRlLnNlcnZpY2UnO1xuaW1wb3J0IHsgQWxlcnRTZXJ2aWNlIH0gZnJvbSAnLi4vYWxlcnQvYWxlcnQuc2VydmljZSc7XG5pbXBvcnQgeyBnZXR0ZXh0IH0gZnJvbSAnLi4vaTE4bi9nZXR0ZXh0JztcbmltcG9ydCB7IEFwaVNlcnZpY2UgfSBmcm9tICdAYzh5L25neC1jb21wb25lbnRzL2FwaSc7XG5pbXBvcnQgeyBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBFTVBUWSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTG9jYXRpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBnZXQsIGlzU3RyaW5nIH0gZnJvbSAnbG9kYXNoLWVzJztcblxuLyoqXG4gKiBTZXJ2aWNlIHRvIG1hbmFnZSB0aGUgbG9naW4uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBMb2dpblNlcnZpY2Uge1xuICByZW1lbWJlck1lOiBib29sZWFuID0gZmFsc2U7XG4gIFRPS0VOX0tFWTogc3RyaW5nID0gJ190Y3k4JztcbiAgVEZBVE9LRU5fS0VZOiBzdHJpbmcgPSAnVEZBVG9rZW4nO1xuICBsb2dpbk1vZGU6IGFueTtcbiAgb2F1dGhPcHRpb25zOiBhbnk7XG4gIGlzRmlyc3RMb2dpbiA9IHRydWU7XG4gIEdSRUVOX01JTl9MRU5HVEhfREVGQVVMVCA9IDg7XG5cbiAgLy8gdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoXG4gIEVSUk9SX01FU1NBR0VTID0ge1xuICAgIG1pbmxlbmd0aDogZ2V0dGV4dCgnUGFzc3dvcmQgbXVzdCBoYXZlIGF0IGxlYXN0IDggY2hhcmFjdGVycyBhbmQgbm8gbW9yZSB0aGFuIDMyLicpLFxuICAgIHBhc3N3b3JkX21pc3NtYXRjaDogZ2V0dGV4dCgnUGFzc3dvcmQgY29uZmlybWF0aW9uIGRvZXMgbm90IG1hdGNoLicpLFxuICAgIG1heGxlbmd0aDogZ2V0dGV4dCgnUGFzc3dvcmQgbXVzdCBoYXZlIGF0IGxlYXN0IDggY2hhcmFjdGVycyBhbmQgbm8gbW9yZSB0aGFuIDMyLicpLFxuICAgIHBhc3N3b3JkX3N0cmVuZ3RoOiBnZXR0ZXh0KFxuICAgICAgJ1lvdXIgcGFzc3dvcmQgaXMgbm90IHN0cm9uZyBlbm91Z2guIFBsZWFzZSBpbmNsdWRlIG51bWJlcnMsIGxvd2VyIGFuZCB1cHBlciBjYXNlIGNoYXJhY3RlcnMnXG4gICAgKSxcbiAgICByZW1vdGVfZXJyb3I6IGdldHRleHQoJ1NlcnZlciBlcnJvciBvY2N1cnJlZC4nKSxcbiAgICBlbWFpbDogZ2V0dGV4dCgnSW52YWxpZCBlbWFpbCBhZGRyZXNzLicpLFxuICAgIHBhc3N3b3JkX2NoYW5nZTogZ2V0dGV4dCgnWW91ciBwYXNzd29yZCBpcyBleHBpcmVkLiBQbGVhc2Ugc2V0IGEgbmV3IHBhc3N3b3JkLicpLFxuICAgIHBhc3N3b3JkX3Jlc2V0X3Rva2VuX2V4cGlyZWQ6IGdldHRleHQoXG4gICAgICAnUGFzc3dvcmQgcmVzZXQgbGluayBleHBpcmVkLiBQbGVhc2UgZW50ZXIgeW91ciBlbWFpbCBhZGRyZXNzIHRvIHJlY2VpdmUgYSBuZXcgb25lLidcbiAgICApLFxuICAgIHRmYV9waW5faW52YWxpZDogZ2V0dGV4dCgnVGhlIGNvZGUgeW91IGVudGVyZWQgaXMgaW52YWxpZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nKSxcbiAgICBwYXR0ZXJuX3Bob25lbnVtYmVyOiBnZXR0ZXh0KFxuICAgICAgJ0ludmFsaWQgcGhvbmUgbnVtYmVyIGZvcm1hdC4gT25seSBkaWdpdHMsIHNwYWNlcywgc2xhc2hlcyAoXCIvXCIpIGFuZCBkYXNoZXMgKFwiLVwiKSBhbGxvd2VkLidcbiAgICApLFxuICAgIHBhdHRlcm5fbmV3UGFzc3dvcmQ6IGdldHRleHQoXG4gICAgICAnUGFzc3dvcmQgbXVzdCBoYXZlIGF0IGxlYXN0IDggY2hhcmFjdGVycyBhbmQgbm8gbW9yZSB0aGFuIDMyIGFuZCBjYW4gb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMgYW5kIGZvbGxvd2luZyBzeW1ib2xzOiBgfiFAIyQlXiYqKClffCstPT87OlxcJ1wiLC48Pnt9W11cXFxcLydcbiAgICApLFxuICAgIGludGVybmF0aW9uYWxfbnVtYmVyX3JlcXVpcmVkOiBnZXR0ZXh0KFxuICAgICAgJ0ludGVybmF0aW9uYWwgcGhvbmUgbnVtYmVyIHJlcXVpcmVkLCBpbiB0aGUgZm9ybWF0ICs0OSA5IDg3NiA1NDMgMjEwLidcbiAgICApLFxuICAgIHBob25lX251bWJlcl9lcnJvcjogZ2V0dGV4dCgnQ291bGQgbm90IHVwZGF0ZSBwaG9uZSBudW1iZXIuJyksXG4gICAgcGluQWxyZWFkeVNlbnQ6IGdldHRleHQoXG4gICAgICAnVGhlIHZlcmlmaWNhdGlvbiBjb2RlIHdhcyBhbHJlYWR5IHNlbnQuIEZvciBhIG5ldyB2ZXJpZmljYXRpb24gY29kZSwgcGxlYXNlIGNsaWNrIG9uIHRoZSBsaW5rIGFib3ZlLidcbiAgICApLFxuICAgIHBhc3N3b3JkQ29uZmlybTogZ2V0dGV4dCgnUGFzc3dvcmQgY29uZmlybWF0aW9uIGRvZXMgbm90IG1hdGNoLicpLFxuICAgIHRmYUV4cGlyZWQ6IGdldHRleHQoJ1R3by1mYWN0b3IgYXV0aGVudGljYXRpb24gdG9rZW4gZXhwaXJlZC4nKVxuICB9O1xuICAvLyB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aFxuXG4gIHByaXZhdGUgU1VDQ0VTU19NRVNTQUdFUyA9IHtcbiAgICBwYXNzd29yZF9jaGFuZ2VkOiBnZXR0ZXh0KCdQYXNzd29yZCBjaGFuZ2VkLiBZb3UgY2FuIG5vdyBsb2cgaW4gdXNpbmcgbmV3IHBhc3N3b3JkLicpLFxuICAgIHBhc3N3b3JkX3Jlc2V0X3JlcXVlc3RlZDogZ2V0dGV4dChcbiAgICAgICdQYXNzd29yZCByZXNldCByZXF1ZXN0IGhhcyBiZWVuIHNlbnQuIFBsZWFzZSBjaGVjayB5b3VyIGVtYWlsLidcbiAgICApLFxuICAgIHJlc2VuZF9zbXM6IGdldHRleHQoJ1ZlcmlmaWNhdGlvbiBjb2RlIFNNUyByZXNlbnQuJyksXG4gICAgc2VuZF9zbXM6IGdldHRleHQoJ1ZlcmlmaWNhdGlvbiBjb2RlIFNNUyBzZW50LicpXG4gIH07XG5cbiAgcHJpdmF0ZSBwYXNzd29yZFN0cmVuZ3RoU2V0dGluZyA9IHtcbiAgICBlbmZvcmNlUGFzc3dvcmRTdHJlbmd0aDogZmFsc2UsXG4gICAgZ3JlZW5NaW5MZW5ndGg6IHRoaXMuR1JFRU5fTUlOX0xFTkdUSF9ERUZBVUxULFxuICAgIHBhc3N3b3JkU3RyZW5ndGhWYWxpZGl0eTogZmFsc2VcbiAgfTtcblxuICBwcml2YXRlIGxvZ2luTW9kZUZpbHRlcnMgPSB7XG4gICAgaXNPYXV0aDJJbnRlcm5hbDogKHsgdHlwZSwgdmlzaWJsZU9uTG9naW5QYWdlfSk6IGJvb2xlYW4gPT4gdHlwZSA9PT0gVGVuYW50TG9naW5PcHRpb25UeXBlLk9BVVRIMl9JTlRFUk5BTCAmJiB2aXNpYmxlT25Mb2dpblBhZ2UsXG4gICAgaXNCYXNpYzogKHsgdHlwZSwgdmlzaWJsZU9uTG9naW5QYWdlIH0pOiBib29sZWFuID0+IHR5cGUgPT09IFRlbmFudExvZ2luT3B0aW9uVHlwZS5CQVNJQyAmJiB2aXNpYmxlT25Mb2dpblBhZ2UsXG4gICAgaXNPYXV0aDI6ICh7dHlwZSwgdmlzaWJsZU9uTG9naW5QYWdlLCBncmFudFR5cGV9KTogYm9vbGVhbiA9PiB0eXBlID09PSBUZW5hbnRMb2dpbk9wdGlvblR5cGUuT0FVVEgyICYmIHZpc2libGVPbkxvZ2luUGFnZSAmJiBncmFudFR5cGUgPT09ICdBVVRIT1JJWkFUSU9OX0NPREUnXG4gIH07XG5cbiAgcHJpdmF0ZSBsb2NhbGhvc3RSZWdFeHAgPSBuZXcgUmVnRXhwKCdsb2NhbGhvc3QnKTtcbiAgcHJpdmF0ZSBsb2NhbGhvc3RJcFJlZ0V4cCA9IG5ldyBSZWdFeHAoJzEyNy4wLjAuMScpO1xuICBwcml2YXRlIHNob3dUZW5hbnRSZWdFeHAgPSBuZXcgUmVnRXhwKCdzaG93VGVuYW50Jyk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjbGllbnQ6IEZldGNoQ2xpZW50LFxuICAgIHByaXZhdGUgYmFzaWNBdXRoOiBCYXNpY0F1dGgsXG4gICAgcHJpdmF0ZSBjb29raWVBdXRoOiBDb29raWVBdXRoLFxuICAgIHByaXZhdGUgdWk6IEFwcFN0YXRlU2VydmljZSxcbiAgICBwcml2YXRlIHVzZXI6IFVzZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgdGVuYW50OiBUZW5hbnRTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhbHRpbWU6IFJlYWx0aW1lLFxuICAgIHByaXZhdGUgYWxlcnQ6IEFsZXJ0U2VydmljZSxcbiAgICBwcml2YXRlIGFwaTogQXBpU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGxvY2F0aW9uOiBMb2NhdGlvblN0cmF0ZWd5XG4gICkge1xuICAgIHRoaXMuYXV0b0xvZ291dCgpO1xuICAgIHRoaXMuaW5pdExvZ2luT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGVuYW50LlxuICAgKiBAcmV0dXJuIFRoZSB0ZW5hbnQgbmFtZS5cbiAgICovXG4gIGdldFRlbmFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQudGVuYW50O1xuICB9XG5cbiAgaW5pdExvZ2luT3B0aW9ucygpIHtcbiAgICBjb25zdCBsb2dpbk9wdGlvbnMgPSB0aGlzLnVpLnN0YXRlLmxvZ2luT3B0aW9ucyB8fCBbXTtcbiAgICB0aGlzLmxvZ2luTW9kZSA9IGxvZ2luT3B0aW9ucy5maW5kKHRoaXMubG9naW5Nb2RlRmlsdGVycy5pc09hdXRoMkludGVybmFsKSB8fFxuICAgICAgbG9naW5PcHRpb25zLmZpbmQodGhpcy5sb2dpbk1vZGVGaWx0ZXJzLmlzQmFzaWMpIHx8XG4gICAgICBsb2dpbk9wdGlvbnMuZmluZCh0aGlzLmxvZ2luTW9kZUZpbHRlcnMuaXNPYXV0aDIpIHx8IHsgdHlwZTogVGVuYW50TG9naW5PcHRpb25UeXBlLkJBU0lDIH07XG4gICAgdGhpcy5vYXV0aE9wdGlvbnMgPSBsb2dpbk9wdGlvbnMuZmluZCh0aGlzLmxvZ2luTW9kZUZpbHRlcnMuaXNPYXV0aDIpIHx8IHt9O1xuICB9XG5cbiAgcmVkaXJlY3RUb09hdXRoKCkge1xuICAgIGNvbnN0IHsgaW5pdFJlcXVlc3QgfSA9IHRoaXMub2F1dGhPcHRpb25zO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gKHRoaXMubG9jYXRpb24gPyAodGhpcy5sb2NhdGlvbiBhcyBhbnkpLl9wbGF0Zm9ybUxvY2F0aW9uIDogd2luZG93KS5sb2NhdGlvblxuICAgICAgLmhyZWY7XG4gICAgY29uc3QgcmVkaXJlY3RVcmwgPSBlbmNvZGVVUklDb21wb25lbnQoZnVsbFBhdGgpO1xuICAgIGNvbnN0IG9yaWdpblVyaVBhcmFtID0gYCR7aW5pdFJlcXVlc3QuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/J31vcmlnaW5Vcmk9JHtyZWRpcmVjdFVybH1gO1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYCR7aW5pdFJlcXVlc3R9JHtvcmlnaW5VcmlQYXJhbX1gO1xuICB9XG5cbiAgYXV0b0xvZ291dCgpIHtcbiAgICBjb25zdCBlcnJvclBhdHRlcm4gPSAvaW52YWxpZFxcc2NyZWRlbnRpYWxzLipwaW4uKmdlbmVyYXRlL2k7XG4gICAgY29uc3QgaXNUZmFFeHBpcmVkID0gZGF0YSA9PlxuICAgICAgZGF0YSAmJiB0eXBlb2YgZGF0YS5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlcnJvclBhdHRlcm4udGVzdChkYXRhLm1lc3NhZ2UpO1xuICAgIHRoaXMudWkuY3VycmVudFVzZXJcbiAgICAgIC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAodSA9PlxuICAgICAgICAgIHUgPyB0aGlzLmFwaS5ob29rUmVzcG9uc2UoKHsgcmVzcG9uc2UgfSkgPT4gcmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIDogRU1QVFlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZShhc3luYyAoYXBpQ2FsbDogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVzcG9uc2UgfSA9IGFwaUNhbGw7XG4gICAgICAgIGxldCB3aWxsTG9nb3V0ID0gZmFsc2U7XG4gICAgICAgIGlmIChpc1RmYUV4cGlyZWQocmVzcG9uc2UuZGF0YSkpIHtcbiAgICAgICAgICB3aWxsTG9nb3V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmpzb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5jbG9uZSgpLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpc1RmYUV4cGlyZWQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgd2lsbExvZ291dCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWxsTG9nb3V0KSB7XG4gICAgICAgICAgdGhpcy5sb2dvdXQoZmFsc2UpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hbGVydC5kYW5nZXIodGhpcy5FUlJPUl9NRVNTQUdFUy50ZmFFeHBpcmVkKSwgNTAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbWluaW1hbCBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGEgcGFzc3dvcmQgc2hvdWxkIGhhdmUgdG8gYmUgY29uc2lkZXJlZCBhIOKAnGdyZWVu4oCdIHN0cm9uZyBvbmUuXG4gICAqIEByZXR1cm4gVGhlIG1pbiBsZW5ndGggZm9yIHBhc3N3b3JkIG9yIGRlZmF1bHQgdmFsdWUuXG4gICAqL1xuICBhc3luYyBnZXRHcmVlbk1pbkxlbmd0aCgpIHtcbiAgICBjb25zdCB7IGdyZWVuTWluTGVuZ3RoIH0gPSBhd2FpdCB0aGlzLmdldEJhc2ljQXV0aExvZ2luT3B0aW9uKCkgfHwgeyBncmVlbk1pbkxlbmd0aDogbnVsbCB9O1xuICAgIHRoaXMucGFzc3dvcmRTdHJlbmd0aFNldHRpbmcuZ3JlZW5NaW5MZW5ndGggPSBncmVlbk1pbkxlbmd0aCB8fCB0aGlzLkdSRUVOX01JTl9MRU5HVEhfREVGQVVMVDtcbiAgICByZXR1cm4gdGhpcy5wYXNzd29yZFN0cmVuZ3RoU2V0dGluZy5ncmVlbk1pbkxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcGFzc3dvcmQgc3RyZW5ndGggaXMgZW5mb3JjZWQgZm9yIHN5c3RlbVxuICAgKiBieSByZXRyaWV2aW5nIHZhbHVlIG9mIGBlbmZvcmNlU3RyZW5ndGhgIHByb3BlcnR5IGZyb20gbG9naW5PcHRpb25zIHJlc3BvbnNlXG4gICAqIEBwYXJhbSByZWZyZXNoIGJvb2xlYW4gdXNlZCB0byByZWZyZXNoIHRoZSBhcHAgc3RhdGUgd2hlcmUgcmVzdWx0IG9mIGxvZ2luT3B0aW9ucyByZXNwb25zZSBpcyBzdG9yZWQuXG4gICAqIElmIGZhbHNlLCBpdCB0YWtlcyB2YWx1ZSBmcm9tIG1lbW9yeSxcbiAgICogaWYgdHJ1ZSwgaXQgcmVmcmVzaCB0aGUgYXBwIHN0YXRlIHZhbHVlIGFuZCB0aGVuIHJldHJpdmVzIGRhdGEuXG4gICAqIEByZXR1cm4gYm9vbGVhbiB2YWx1ZSwgdHJ1ZSBpZiBlbmZvcmNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgYXN5bmMgZ2V0RW5mb3JjZVBhc3N3b3JkU3RyZW5ndGgocmVmcmVzaD8pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCYXNpY0F1dGhMb2dpbk9wdGlvbihyZWZyZXNoKS50aGVuKChsb2dpbk9wdGlvbikgPT4ge1xuICAgICAgY29uc3QgZW5mb3JjZVBhc3N3b3JkU3RyZW5ndGggPSBnZXQobG9naW5PcHRpb24sICdlbmZvcmNlU3RyZW5ndGgnKTtcbiAgICAgIGlmIChpc1N0cmluZyhlbmZvcmNlUGFzc3dvcmRTdHJlbmd0aCkpIHtcbiAgICAgICAgdGhpcy5wYXNzd29yZFN0cmVuZ3RoU2V0dGluZy5lbmZvcmNlUGFzc3dvcmRTdHJlbmd0aCA9IGVuZm9yY2VQYXNzd29yZFN0cmVuZ3RoID09PSAndHJ1ZScgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhc3N3b3JkU3RyZW5ndGhTZXR0aW5nLmVuZm9yY2VQYXNzd29yZFN0cmVuZ3RoID0gISFlbmZvcmNlUGFzc3dvcmRTdHJlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhc3N3b3JkU3RyZW5ndGhTZXR0aW5nLmVuZm9yY2VQYXNzd29yZFN0cmVuZ3RoO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwYXNzd29yZCBzdHJlbmd0aCBpcyBlbmZvcmNlZCBmb3IgcGFydGljdWxhciB0ZW5hbnRcbiAgICogYnkgcmV0cmlldmluZyB2YWx1ZSBvZiBgc3RyZW5ndGhWYWxpZGl0eWAgcHJvcGVydHkgZnJvbSBsb2dpbk9wdGlvbnMgcmVzcG9uc2VcbiAgICogQHBhcmFtIHJlZnJlc2ggYm9vbGVhbiB1c2VkIHRvIHJlZnJlc2ggdGhlIGFwcCBzdGF0ZSB3aGVyZSByZXN1bHQgb2YgbG9naW5PcHRpb25zIHJlc3BvbnNlIGlzIHN0b3JlZC5cbiAgICogSWYgZmFsc2UsIGl0IHRha2VzIHZhbHVlIGZyb20gbWVtb3J5LFxuICAgKiBpZiB0cnVlLCBpdCByZWZyZXNoIHRoZSBhcHAgc3RhdGUgdmFsdWUgYW5kIHRoZW4gcmV0cml2ZXMgZGF0YS5cbiAgICogQHJldHVybiBib29sZWFuIHZhbHVlLCB0cnVlIGlmIGVuZm9yY2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBhc3luYyBnZXRQYXNzd29yZFN0cmVuZ3RoVmFsaWRpdHkocmVmcmVzaD8pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCYXNpY0F1dGhMb2dpbk9wdGlvbihyZWZyZXNoKS50aGVuKChsb2dpbk9wdGlvbikgPT4ge1xuICAgICAgY29uc3Qgc3RyZW5ndGhWYWxpZGl0eSA9IGdldChsb2dpbk9wdGlvbiwgJ3N0cmVuZ3RoVmFsaWRpdHknKTtcbiAgICAgIGlmIChpc1N0cmluZyhzdHJlbmd0aFZhbGlkaXR5KSkge1xuICAgICAgICB0aGlzLnBhc3N3b3JkU3RyZW5ndGhTZXR0aW5nLnBhc3N3b3JkU3RyZW5ndGhWYWxpZGl0eSA9IHN0cmVuZ3RoVmFsaWRpdHkgPT09ICd0cnVlJyA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFzc3dvcmRTdHJlbmd0aFNldHRpbmcucGFzc3dvcmRTdHJlbmd0aFZhbGlkaXR5ID0gISFzdHJlbmd0aFZhbGlkaXR5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFzc3dvcmRTdHJlbmd0aFNldHRpbmcucGFzc3dvcmRTdHJlbmd0aFZhbGlkaXR5O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGRldGVybWluZXMgaWYgZW5mb3JjZWQgc3RyZW5ndGggY2hlY2tzIHNob3VsZCBiZSBlbmFibGVkIGZvciBjdXJyZW50IHRlbmFudFxuICAgKiBiYXNlZCBvbiBwcm9wZXJ0aWVzIHJldHJpZXZlZCBmcm9tIGxvZ2luT3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBzcGVjaWZpYyBvcHRpb25zOlxuICAgKiAgICAtIHtyZWZyZXNoOiB0cnVlfSAtIHJlZnJlc2hlcyB2YWx1ZXMgb2YgYXBwIHN0YXRlIGFuZCByZXR1cm5zIGZyZXNoIHZhbHVlcyBhcyByZXN1bHQgb2YgY2FsbFxuICAgKiBAcmV0dXJuIGJvb2xlYW4gdmFsdWUsIHRydWUgaWYgc3RyZW5ndGggaXMgZW5mb3JjZWQgZm9yIHRlbmFudCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgYXN5bmMgZ2V0UGFzc3dvcmRTdHJlbmd0aEVuZm9yY2VkKG9wdGlvbnM/KSB7XG4gICAgY29uc3QgcmVmcmVzaCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yZWZyZXNoO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbdGhpcy5nZXRFbmZvcmNlUGFzc3dvcmRTdHJlbmd0aChyZWZyZXNoKSwgdGhpcy5nZXRQYXNzd29yZFN0cmVuZ3RoVmFsaWRpdHkocmVmcmVzaCldKS50aGVuKCh2YWx1ZXMpID0+IHtcbiAgICAgIGNvbnN0IFtlbmZvcmNlUGFzc3dvcmRTdHJlbmd0aCwgcGFzc3dvcmRTdHJlbmd0aFZhbGlkaXR5XSA9IHZhbHVlcztcbiAgICAgIHJldHVybiBlbmZvcmNlUGFzc3dvcmRTdHJlbmd0aCB8fCBwYXNzd29yZFN0cmVuZ3RoVmFsaWRpdHk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBiYWNrZW5kIGVycm9ycy5cbiAgICovXG4gIGNsZWFuTWVzc2FnZXMoKSB7XG4gICAgdGhpcy5hbGVydC5jbGVhckFsbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgc3VjY2VzcyBtZXNzYWdlXG4gICAqIEBwYXJhbSBzdWNjZXNzS2V5IFRoZSBrZXkgb2YgdGhlIHN1Y2Nlc3MgbWVzc2FnZSBhcyB1c2VkIGluIFNVQ0NFU1NfTUVTU0FHRVNcbiAgICovXG4gIGFkZFN1Y2Nlc3NNZXNzYWdlKHN1Y2Nlc3NLZXk6IHN0cmluZykge1xuICAgIGNvbnN0IHN1Y2Nlc3NNZXNzYWdlID0gdGhpcy5TVUNDRVNTX01FU1NBR0VTW3N1Y2Nlc3NLZXldO1xuICAgIGlmIChzdWNjZXNzTWVzc2FnZSkge1xuICAgICAgdGhpcy5hbGVydC5hZGQoe1xuICAgICAgICB0ZXh0OiBzdWNjZXNzTWVzc2FnZSxcbiAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICB0aW1lb3V0OiAwXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdHJhdGVneS4gRGVmYXVsdHMgdG8gY29va2llLCBpZiBhIHRva2VuXG4gICAqIGlzIGZvdW5kIGluIGxvY2FsIG9yIHNlc3Npb24gc3RvcmFnZSB3ZSBzd2l0Y2ggdG8gYmFzaWMgYXV0aC5cbiAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgYXV0aCBzdHJhdGVneS5cbiAgICovXG4gIGdldEF1dGhTdHJhdGVneSgpOiBJQXV0aGVudGljYXRpb24ge1xuICAgIGxldCBhdXRoU3RyYXRlZ3kgPSB0aGlzLmNvb2tpZUF1dGggYXMgSUF1dGhlbnRpY2F0aW9uO1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5nZXRTdG9yZWRUb2tlbigpO1xuICAgIGNvbnN0IHRmYSA9IHRoaXMuZ2V0U3RvcmVkVGZhVG9rZW4oKTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGF1dGhTdHJhdGVneSA9IHRoaXMuYmFzaWNBdXRoO1xuICAgICAgdGhpcy5zZXRDcmVkZW50aWFscyh7IHRva2VuLCB0ZmEgfSwgdGhpcy5iYXNpY0F1dGgpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aFN0cmF0ZWd5O1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyB0aGUgdXNlIG9mIGJhc2ljIGF1dGggYXMgc3RyYXRlZ3kgd2l0aCB0aGlzIGNyZWRlbnRpYWxzLlxuICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgVGhlIGNyZWRlbnRpYWxzIHRvIHVzZS5cbiAgICovXG4gIHVzZUJhc2ljQXV0aChjcmVkZW50aWFsczogSUNyZWRlbnRpYWxzKSB7XG4gICAgdGhpcy5zZXRDcmVkZW50aWFscyhjcmVkZW50aWFscywgdGhpcy5iYXNpY0F1dGgpO1xuICAgIHJldHVybiB0aGlzLmJhc2ljQXV0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmllcyB0byBsb2dpbiBhIHVzZXIgd2l0aCB0aGUgZ2l2ZW4gY3JlZGVudGlhbHMuXG4gICAqIElmIHN1Y2Nlc3NmdWwsIHRoZSBjdXJyZW50IHRlbmFudCBhbmQgdXNlciBpcyBzZXQuIElmIG5vdCBhbiBlcnJvclxuICAgKiBpcyB0aHJvd24uIEl0IGFsc28gdmVyaWZpZXMgaWYgdGhlIHVzZXIgaXMgYWxsb3dlZCB0byBvcGVuIHRoZVxuICAgKiBjdXJyZW50IGFwcC5cbiAgICogQHBhcmFtIGF1dGggVGhlIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5IHVzZWQuXG4gICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgY3JlZGVudGlhbHMgdG8gdHJ5IHRvIGxvZ2luLlxuICAgKi9cbiAgYXN5bmMgbG9naW4oYXV0aDogSUF1dGhlbnRpY2F0aW9uID0gdGhpcy5nZXRBdXRoU3RyYXRlZ3koKSwgY3JlZGVudGlhbHM/OiBJQ3JlZGVudGlhbHMpIHtcbiAgICB0aGlzLmNsaWVudC5zZXRBdXRoKGF1dGgpO1xuXG4gICAgY29uc3QgdGVuYW50UmVzID0gYXdhaXQgdGhpcy50ZW5hbnQuY3VycmVudCgpO1xuICAgIGNvbnN0IHRlbmFudCA9IHRlbmFudFJlcy5kYXRhO1xuXG4gICAgaWYgKGF3YWl0IHRoaXMuc3dpdGNoTG9naW5Nb2RlKGNyZWRlbnRpYWxzKSkge1xuICAgICAgYXV0aCA9IHRoaXMuY29va2llQXV0aDtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyUmVzID0gYXdhaXQgdGhpcy51c2VyLmN1cnJlbnQoKTtcbiAgICBjb25zdCB1c2VyID0gdXNlclJlcy5kYXRhO1xuICAgIGF3YWl0IHRoaXMudmVyaWZ5QXBwQWNjZXNzKCk7XG5cbiAgICBjb25zdCBzdXBwb3J0VXNlck5hbWUgPSB0aGlzLmdldFN1cHBvcnRVc2VyTmFtZShjcmVkZW50aWFscyk7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLnNldENyZWRlbnRpYWxzKFxuICAgICAge1xuICAgICAgICB0ZW5hbnQ6IHRlbmFudC5uYW1lLFxuICAgICAgICB1c2VyOiAoc3VwcG9ydFVzZXJOYW1lID8gYCR7c3VwcG9ydFVzZXJOYW1lfSRgIDogJycpICsgdXNlci51c2VyTmFtZVxuICAgICAgfSxcbiAgICAgIGF1dGhcbiAgICApO1xuXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICB0aGlzLnN0b3JlQmFzaWNBdXRoVG9rZW4odG9rZW4pO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuYXV0aEZ1bGZpbGxlZCh0ZW5hbnQsIHVzZXIsIHN1cHBvcnRVc2VyTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgdGVuYW50LCB1c2VyIGFuZCBzdXBwb3J0IHVzZXIgaW5mbyB0byB0aGUgYXBwIHN0YXRlLlxuICAgKiBAcGFyYW0gdGVuYW50IFRoZSBjdXJyZW50IHRlbmFudCBvYmplY3QuXG4gICAqIEBwYXJhbSB1c2VyIFRoZSBjdXJyZW50IHVzZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0gc3VwcG9ydFVzZXJOYW1lIFRoZSBjdXJyZW50IHN1cHBvcnQgdXNlciBuYW1lLlxuICAgKi9cbiAgYXN5bmMgYXV0aEZ1bGZpbGxlZCh0ZW5hbnQ/LCB1c2VyPywgc3VwcG9ydFVzZXJOYW1lPykge1xuICAgIGlmICghdGVuYW50KSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMudGVuYW50LmN1cnJlbnQoKTtcbiAgICAgIHRlbmFudCA9IGRhdGE7XG4gICAgICB0aGlzLmNsaWVudC50ZW5hbnQgPSB0ZW5hbnQubmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgdGhpcy51c2VyLmN1cnJlbnQoKTtcbiAgICAgIHVzZXIgPSBkYXRhO1xuICAgIH1cblxuICAgIGlmICghc3VwcG9ydFVzZXJOYW1lKSB7XG4gICAgICBzdXBwb3J0VXNlck5hbWUgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudWkuc2V0VXNlcih7IHVzZXIsIHN1cHBvcnRVc2VyTmFtZSB9KTtcbiAgICB0aGlzLnVpLmN1cnJlbnRUZW5hbnQubmV4dCh0ZW5hbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaCB0aGUgbG9naW4gbW9kZSB0byBDb29raWVBdXRoIGlmIHRoZVxuICAgKiB1c2VyIGhhcyBjb25maWd1cmVkIHRvIHVzZSBpdCBpbiBsb2dpbk9wdGlvbnMuXG4gICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgY3JlZGVudGlhbHMgZm9yIHRoYXQgbG9naW5cbiAgICovXG4gIGFzeW5jIHN3aXRjaExvZ2luTW9kZShjcmVkZW50aWFscz86IElDcmVkZW50aWFscykge1xuICAgIGNvbnN0IGlzUGFzc3dvcmRHcmFudExvZ2luID0gdGhpcy5pc1Bhc3N3b3JkR3JhbnRMb2dpbihjcmVkZW50aWFscyk7XG4gICAgaWYgKGlzUGFzc3dvcmRHcmFudExvZ2luICYmIGNyZWRlbnRpYWxzKSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdlbmVyYXRlT2F1dGhUb2tlbihjcmVkZW50aWFscyk7XG4gICAgICBpZiAoIShyZXMgYXMgUmVzcG9uc2UpLm9rKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICAgICAgdGhyb3cgeyByZXMsIGRhdGEgfTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jbGllbnQuc2V0QXV0aCh0aGlzLmNvb2tpZUF1dGgpO1xuICAgICAgdGhpcy5jbGVhbkxvY2FsU3RvcmFnZSgpO1xuICAgICAgdGhpcy5iYXNpY0F1dGgubG9nb3V0KCk7XG4gICAgfVxuICAgIHJldHVybiBpc1Bhc3N3b3JkR3JhbnRMb2dpbjtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlT2F1dGhUb2tlbihjcmVkZW50aWFscz86IElDcmVkZW50aWFscykge1xuICAgIGlmICh0aGlzLmlzUGFzc3dvcmRHcmFudExvZ2luKGNyZWRlbnRpYWxzKSAmJiBjcmVkZW50aWFscykge1xuICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGdyYW50X3R5cGU6ICdQQVNTV09SRCcsXG4gICAgICAgIHVzZXJuYW1lOiBjcmVkZW50aWFscy51c2VyLFxuICAgICAgICBwYXNzd29yZDogY3JlZGVudGlhbHMucGFzc3dvcmQsXG4gICAgICAgIHRmYV9jb2RlOiBjcmVkZW50aWFscy50ZmFcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh0aGlzLmxvZ2luTW9kZS5pbml0UmVxdWVzdC5zcGxpdCgnPycpLnBvcCgpKTtcbiAgICAgIGNyZWRlbnRpYWxzLnRlbmFudCA9IHVybFBhcmFtcy5nZXQoJ3RlbmFudF9pZCcpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50LmZldGNoKGB0ZW5hbnQvb2F1dGg/JHt1cmxQYXJhbXMudG9TdHJpbmcoKX1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBwYXJhbXMudG9TdHJpbmcoKSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlzUGFzc3dvcmRHcmFudExvZ2luKGNyZWRlbnRpYWxzPzogSUNyZWRlbnRpYWxzKSB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgIXRoaXMuaXNTdXBwb3J0VXNlcihjcmVkZW50aWFscykgJiZcbiAgICAgIHRoaXMubG9naW5Nb2RlICYmXG4gICAgICB0aGlzLmxvZ2luTW9kZS50eXBlID09PSBUZW5hbnRMb2dpbk9wdGlvblR5cGUuT0FVVEgyX0lOVEVSTkFMXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBpZiB0aGUgcHJvdmlkZWQgY3JlZGVudGlhbHMgdXNlIGEgc3VwcG9ydCB1c2VyIHRvIGxvZyBpbiBvciBub3QuXG4gICAqIEBwYXJhbSBjcmVkZW50aWFscyBDcmVkZW50aWFscyB0byBjaGVjay5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiB1c2VyIGlzIGEgc3VwcG9ydCB1c2VyLlxuICAgKi9cbiAgaXNTdXBwb3J0VXNlcihjcmVkZW50aWFscz86IElDcmVkZW50aWFscyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBjcmVkZW50aWFscyAmJiBjcmVkZW50aWFscy51c2VyLmluY2x1ZGVzKCckJyk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpZXMgaWYgdGhlIHRlbmFudCBpbnB1dCBmaWVsZCBzaG91bGQgYmUgc2hvd25cbiAgICogb3Igbm90LlxuICAgKiBAcmV0dXJucyBJZiB0cnVlLCBzaG93IHRoZSB0ZW5hbnQgaW5wdXQuXG4gICAqL1xuICBzaG93VGVuYW50KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy51aS5zdGF0ZS5sb2dpbk9wdGlvbnMgfHwgdGhpcy5pc0xvY2FsKCkgfHwgdGhpcy5pc1Nob3dUZW5hbnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSB1c2VyIG91dFxuICAgKiBAcGFyYW0gcmVsb2FkIElmIHNldCB0byBmYWxzZSwgdGhlIHBhZ2Ugd2lsbCBub3QgcmVsb2FkXG4gICAqL1xuICBhc3luYyBsb2dvdXQocmVsb2FkID0gdHJ1ZSkge1xuICAgIGxldCByZXNEYXRhID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW2Jhc2ljUmVzLCBjb29raWVSZXNdID0gYXdhaXQgdGhpcy5yZXNldCgpO1xuICAgICAgcmVzRGF0YSA9IGF3YWl0IGNvb2tpZVJlcy5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRoaXMuYWxlcnQucmVtb3ZlTGFzdERhbmdlcigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAocmVzRGF0YSAmJiByZXNEYXRhLnVybCkge1xuICAgICAgICB0aGlzLnJlZGlyZWN0KHJlc0RhdGEudXJsKTtcbiAgICAgIH0gZWxzZSBpZiAocmVsb2FkKSB7XG4gICAgICAgIHRoaXMubG9jYXRpb24ucmVwbGFjZVN0YXRlKHt9LCAnJywgJycsICcnKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHN0b3JlZCBhdXRoLWRhdGFcbiAgICovXG4gIGFzeW5jIHJlc2V0KCkge1xuICAgIHRoaXMuY2xlYW5Mb2NhbFN0b3JhZ2UoKTtcbiAgICB0aGlzLmNsZWFuU2Vzc2lvblN0b3JhZ2UoKTtcbiAgICB0aGlzLnJlYWx0aW1lLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLnVpLmN1cnJlbnRVc2VyLm5leHQobnVsbCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzLmJhc2ljQXV0aC5sb2dvdXQoKSwgdGhpcy5jb29raWVBdXRoLmxvZ291dCgpXSk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgdGhlIFRGQSB0b2tlbiB0byBsb2NhbCBvciBzZXNzaW9uIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB0ZmFUb2tlbiBUaGUgdGZhIHRva2VuIHRvIHNhdmUuXG4gICAqIEBwYXJhbSBzdG9yYWdlIFRoZSBzdG9yYWdlIHRvIHVzZSAobG9jYWwgb3Igc2Vzc2lvbikuXG4gICAqL1xuICBzYXZlVEZBVG9rZW4odGZhVG9rZW46IHN0cmluZywgc3RvcmFnZTogU3RvcmFnZSkge1xuICAgIHN0b3JhZ2Uuc2V0SXRlbSh0aGlzLlRGQVRPS0VOX0tFWSwgdGZhVG9rZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGhlIG1hbmlmZXN0IC0+IG9uIDQwMSB1c2VyIGhhcyBubyBhY2Nlc3MgdG8gdGhhdCBhcHBsaWNhdGlvblxuICAgKiBhbmQgd2UgdGhyb3cgdGhlIGVycm9yIHVwIHRvIHRoZSBsb2dpbiBmb3JtLlxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5QXBwQWNjZXNzKCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnVpLmxvYWRNYW5pZmVzdCgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoIShleC5yZXMgJiYgZXgucmVzLnN0YXR1cyA9PT0gNDA0ICYmIHRoaXMuaXNMb2NhbCgpKSkge1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGVuYW50IHRvIHRoZSBjbGllbnQgYW5kIHVwZGF0ZXMgdGhlIGNyZWRlbnRpYWxzIG9uIHRoZVxuICAgKiBhdXRoIHN0cmF0ZWd5LlxuICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgVGhlIG5hbWUgb2YgdGhlIHRlbmFudC5cbiAgICogQHBhcmFtIGF1dGhTdHJhdGVneSBUaGUgYXV0aGVudGljYXRpb24gc3RyYXRlZ3kgdXNlZC5cbiAgICogQHJldHVybiBSZXR1cm5zIHRoZSB0b2tlbiBpZiBiYXNpYyBhdXRoLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgcHJpdmF0ZSBzZXRDcmVkZW50aWFscyhjcmVkZW50aWFsczogSUNyZWRlbnRpYWxzLCBhdXRoU3RyYXRlZ3k6IElBdXRoZW50aWNhdGlvbikge1xuICAgIGlmIChjcmVkZW50aWFscy50ZW5hbnQpIHtcbiAgICAgIHRoaXMuY2xpZW50LnRlbmFudCA9IGNyZWRlbnRpYWxzLnRlbmFudDtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYSB0b2tlbiBpcyBhbHJlYWR5IHNldCAoY2FzZSBmb3Igc3VwcG9ydCB1c2VyIGxvZ2luKVxuICAgIC8vIGlmIHllcyAtPiB3ZSBqdXN0IG5lZWQgdG8gdXBkYXRlIHRoZSB1c2VyLCBhbmQgcmV1c2UgdGhlIHRva2VuXG4gICAgLy8gb2YgdGhlIHN1cHBvcnQgdXNlci5cbiAgICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBwYXNzIHVzZXIgYW5kIHRlbmFudCwgdG8gZ2V0XG4gICAgLy8ganVzdCB0aGUgc3RvcmVkIHRva2VuIGFuZCBub3RoaW5nIGVsc2UgKHNlZSBCYXNpY0F1dGgudHM6MzEpLlxuICAgIGNvbnN0IHRva2VuID0gdGhpcy5iYXNpY0F1dGgudXBkYXRlQ3JlZGVudGlhbHMoe1xuICAgICAgdGVuYW50OiBjcmVkZW50aWFscy50ZW5hbnQsXG4gICAgICB1c2VyOiBjcmVkZW50aWFscy51c2VyXG4gICAgfSk7XG4gICAgY29uc3QgbmV3Q3JlZGVudGlhbHMgPSB7IHRva2VuLCAuLi5jcmVkZW50aWFscyB9O1xuXG4gICAgcmV0dXJuIGF1dGhTdHJhdGVneS51cGRhdGVDcmVkZW50aWFscyhuZXdDcmVkZW50aWFscyk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpZXMgaWYgdGhlIGN1cnJlbnQgdXNlciBpcyBhIGRldmVsb3BlciBvciBub3QuXG4gICAqIFJ1bm5pbmcgb24gbG9jYWxob3N0IG1lYW5zIGRldmVsb3BtZW50IG1vZGUuXG4gICAqL1xuICBwcml2YXRlIGlzTG9jYWwoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaG9zdG5hbWUgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxob3N0SXBSZWdFeHAudGVzdChob3N0bmFtZSkgfHwgdGhpcy5sb2NhbGhvc3RSZWdFeHAudGVzdChob3N0bmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZSB0aGUgdG9rZW4gdG8gbG9jYWwgb3Igc2Vzc2lvbiBzdG9yYWdlLlxuICAgKiBAcGFyYW0gdG9rZW4gVGhlIHRva2VuIHRvIHNhdmUuXG4gICAqIEBwYXJhbSBzdG9yYWdlIFRoZSBzdG9yYWdlIHRvIHVzZSAobG9jYWwgb3Igc2Vzc2lvbikuXG4gICAqL1xuICBwcml2YXRlIHNhdmVUb2tlbih0b2tlbjogc3RyaW5nLCBzdG9yYWdlOiBTdG9yYWdlKSB7XG4gICAgc3RvcmFnZS5zZXRJdGVtKHRoaXMuVE9LRU5fS0VZLCB0b2tlbik7XG4gIH1cblxuICBwcml2YXRlIHN0b3JlQmFzaWNBdXRoVG9rZW4odG9rZW46IHN0cmluZykge1xuICAgIHRoaXMuc2F2ZVRva2VuKHRva2VuLCBzZXNzaW9uU3RvcmFnZSk7XG4gICAgaWYgKHRoaXMucmVtZW1iZXJNZSkge1xuICAgICAgdGhpcy5zYXZlVG9rZW4odG9rZW4sIGxvY2FsU3RvcmFnZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjbGVhbkxvY2FsU3RvcmFnZSgpIHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLlRPS0VOX0tFWSk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5URkFUT0tFTl9LRVkpO1xuICB9XG5cbiAgcHJpdmF0ZSBjbGVhblNlc3Npb25TdG9yYWdlKCkge1xuICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5UT0tFTl9LRVkpO1xuICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5URkFUT0tFTl9LRVkpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1Nob3dUZW5hbnQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2hvd1RlbmFudFJlZ0V4cC50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVkaXJlY3QodXJsOiBzdHJpbmcpIHtcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0QmFzaWNBdXRoTG9naW5PcHRpb24ocmVmcmVzaD8pOiBQcm9taXNlPElUZW5hbnRMb2dpbk9wdGlvbj4ge1xuICAgIGlmIChyZWZyZXNoKSB7XG4gICAgICBhd2FpdCB0aGlzLnVpLnJlZnJlc2hMb2dpbk9wdGlvbnMoKTtcbiAgICB9XG4gICAgY29uc3QgbG9naW5PcHRpb25zID0gdGhpcy51aS5zdGF0ZS5sb2dpbk9wdGlvbnMgfHwgW107XG4gICAgY29uc3QgYmFzaWNBdXRoTG9naW5PcHRpb24gPSBsb2dpbk9wdGlvbnMuZmluZCgoeyB0eXBlIH0pID0+IHR5cGUgPT09ICdCQVNJQycpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYmFzaWNBdXRoTG9naW5PcHRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgc3VwcG9ydCB1c2VyIG5hbWUgZnJvbSBjcmVkZW50aWFscy5cbiAgICogQHBhcmFtIGNyZWRlbnRpYWxzIENyZWRlbnRpYWxzIG9iamVjdCAoZGVmYXVsdHMgdG8gdGhlIHN0b3JlZCBvbmUpLlxuICAgKiBAcmV0dXJucyBTdXBwb3J0IHVzZXIgbmFtZS5cbiAgICovXG4gIHByaXZhdGUgZ2V0U3VwcG9ydFVzZXJOYW1lKGNyZWRlbnRpYWxzOiBJQ3JlZGVudGlhbHMgPSB0aGlzLmdldFN0b3JlZENyZWRlbnRpYWxzKCkpOiBzdHJpbmcge1xuICAgIGlmICghY3JlZGVudGlhbHMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdXBwb3J0VXNlck5hbWUgPSBjcmVkZW50aWFscy51c2VyLm1hdGNoKC9eKC4rXFwvKT8oKC4rKVxcJCk/KC4rKT8kLylbM107XG4gICAgcmV0dXJuIHN1cHBvcnRVc2VyTmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNyZWRlbnRpYWxzIG9iamVjdCBmcm9tIHRoZSBzdG9yZWQgdG9rZW4uXG4gICAqIEByZXR1cm5zIENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICovXG4gIHByaXZhdGUgZ2V0U3RvcmVkQ3JlZGVudGlhbHMoKTogSUNyZWRlbnRpYWxzIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuZ2V0U3RvcmVkVG9rZW4oKTtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlVG9rZW4odG9rZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgc3RvcmVkIHRva2VuIGZyb20gbG9jYWwgc3RvcmFnZSBvciBzZXNzaW9uIHN0b3JhZ2UuXG4gICAqIEByZXR1cm5zIFN0b3JlZCB0b2tlbi5cbiAgICovXG4gIHByaXZhdGUgZ2V0U3RvcmVkVG9rZW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5UT0tFTl9LRVkpIHx8IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0odGhpcy5UT0tFTl9LRVkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgc3RvcmVkIFRGQSB0b2tlbiBmcm9tIGxvY2FsIHN0b3JhZ2Ugb3Igc2Vzc2lvbiBzdG9yYWdlLlxuICAgKiBAcmV0dXJucyBTdG9yZWQgVEZBIHRva2VuLlxuICAgKi9cbiAgcHJpdmF0ZSBnZXRTdG9yZWRUZmFUb2tlbigpOiBzdHJpbmcge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlRGQVRPS0VOX0tFWSkgfHwgc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlRGQVRPS0VOX0tFWSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyB0b2tlbiB0byBjcmVkZW50aWFscyBvYmplY3QuXG4gICAqIEBwYXJhbSB0b2tlbiBUb2tlbiB0byBkZWNvZGUuXG4gICAqIEByZXR1cm5zIENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICovXG4gIHByaXZhdGUgZGVjb2RlVG9rZW4odG9rZW46IHN0cmluZyk6IElDcmVkZW50aWFscyB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUod2luZG93LmF0b2IodG9rZW4pKSk7XG4gICAgY29uc3Qgc3BsaXQgPSBkZWNvZGVkLm1hdGNoKC8oKFteL10qKVxcLyk/KFteLzpdKyk6KC4rKS8pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbmFudDogc3BsaXRbMl0sXG4gICAgICB1c2VyOiBzcGxpdFszXSxcbiAgICAgIHBhc3N3b3JkOiBzcGxpdFs0XVxuICAgIH07XG4gIH1cbn1cbiJdfQ==