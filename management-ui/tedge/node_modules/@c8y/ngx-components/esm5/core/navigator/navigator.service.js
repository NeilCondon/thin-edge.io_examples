import * as tslib_1 from "tslib";
import { Injectable, InjectionToken, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { BehaviorSubject, Subject } from 'rxjs';
import { map, shareReplay } from 'rxjs/operators';
import { fromTrigger, sortByPriority, stateToFactory } from '../common/extension-hooks';
import { StateService } from '../common/state-service.abstract';
import { NavigatorNodeRoot } from './navigator-node-root';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
/**
 * A hook to use for Multi Provider extension.
 */
export var HOOK_NAVIGATOR_NODES = new InjectionToken('NavigatorNodesFactory');
/**
 * A service which defines the navigator.
 */
var NavigatorService = /** @class */ (function (_super) {
    tslib_1.__extends(NavigatorService, _super);
    function NavigatorService(injector, router) {
        var _this = _super.call(this) || this;
        _this.injector = injector;
        _this.router = router;
        /**
         * Refresh the extension factories subject.
         * @readonly
         */
        _this.refreshTrigger = new Subject();
        /**
         * @ignore
         */
        _this.state$ = new BehaviorSubject(new Set());
        /**
         * Indicates whether the menu entry associated with the given URL should be expanded.
         */
        _this.firstUrl = true;
        var rootNode = new NavigatorNodeRoot();
        _this.items$ = fromTrigger(router, _this.refreshTrigger, [
            function () { return _this.injector.get(HOOK_NAVIGATOR_NODES, []); },
            stateToFactory(_this.state$)
        ]).pipe(map(function (nodes) {
            var noParent = nodes.filter(function (node) { return !node.parent; });
            var withParent = nodes.filter(function (node) { return node.parent; });
            // Based on the sortedNodes array, the nodes are sequentially created.
            // Nodes sorting is done in two steps to have the top-level nodes first.
            // This way, by the time we are adding a child node, the parent node is already present.
            var sortedNodes = sortByPriority(noParent).concat(sortByPriority(withParent));
            rootNode.empty();
            sortedNodes.forEach(function (node) { return rootNode.addRoot(node); });
            return rootNode.children;
        }), shareReplay(1));
        return _this;
    }
    /**
     * Checks whenever a navigator entry associated with the given URL should be expanded.
     * @param {NavigatorNode} node Navigator node.
     */
    NavigatorService.prototype.openOnFirstUrl = function (node) {
        if (this.firstUrl && !!node.path) {
            return (this.router.isActive(node.path, node.routerLinkExact) || node.openOnStart(this.router.url));
        }
        return false;
    };
    Object.defineProperty(NavigatorService.prototype, "state", {
        /**
         * Returns the current state.
         * @readonly
         * @returns The current set of actions.
         */
        get: function () {
            return this.state$.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Refresh the extension factories.
     */
    NavigatorService.prototype.refresh = function () {
        this.refreshTrigger.next(1);
    };
    /**
     * Adds a new node to the navigator.
     * @param {NavigatorNode} node Navigator node to add.
     */
    NavigatorService.prototype.add = function (node) {
        this.state.add(node);
        this.emitNewState();
    };
    /**
     * Removes a node from the navigator.
     * @param {NavigatorNode} node Navigator node to remove.
     */
    NavigatorService.prototype.remove = function (node) {
        this.state.delete(node);
        this.emitNewState();
    };
    NavigatorService.ctorParameters = function () { return [
        { type: Injector },
        { type: Router }
    ]; };
    NavigatorService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function NavigatorService_Factory() { return new NavigatorService(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.Router)); }, token: NavigatorService, providedIn: "root" });
    NavigatorService = tslib_1.__decorate([
        Injectable({
            providedIn: 'root'
        })
    ], NavigatorService);
    return NavigatorService;
}(StateService));
export { NavigatorService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdG9yLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYzh5L25neC1jb21wb25lbnRzLyIsInNvdXJjZXMiOlsiY29yZS9uYXZpZ2F0b3IvbmF2aWdhdG9yLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekMsT0FBTyxFQUFFLGVBQWUsRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRCxPQUFPLEVBRUwsV0FBVyxFQUNYLGNBQWMsRUFDZCxjQUFjLEVBQ2YsTUFBTSwyQkFBMkIsQ0FBQztBQUNuQyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFHaEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7OztBQUUxRDs7R0FFRztBQUNILE1BQU0sQ0FBQyxJQUFNLG9CQUFvQixHQUFHLElBQUksY0FBYyxDQUFDLHVCQUF1QixDQUFDLENBQUM7QUFFaEY7O0dBRUc7QUFJSDtJQUFzQyw0Q0FBWTtJQXVCaEQsMEJBQW9CLFFBQWtCLEVBQVUsTUFBYztRQUE5RCxZQUNFLGlCQUFPLFNBb0JSO1FBckJtQixjQUFRLEdBQVIsUUFBUSxDQUFVO1FBQVUsWUFBTSxHQUFOLE1BQU0sQ0FBUTtRQWhCOUQ7OztXQUdHO1FBQ00sb0JBQWMsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBRXhDOztXQUVHO1FBQ00sWUFBTSxHQUFHLElBQUksZUFBZSxDQUFxQixJQUFJLEdBQUcsRUFBaUIsQ0FBQyxDQUFDO1FBRXBGOztXQUVHO1FBQ0gsY0FBUSxHQUFHLElBQUksQ0FBQztRQUlkLElBQU0sUUFBUSxHQUFHLElBQUksaUJBQWlCLEVBQUUsQ0FBQztRQUN6QyxLQUFJLENBQUMsTUFBTSxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsS0FBSSxDQUFDLGNBQWMsRUFBRTtZQUNyRCxjQUFNLE9BQUEsS0FBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsb0JBQW9CLEVBQUUsRUFBRSxDQUFDLEVBQTNDLENBQTJDO1lBQ2pELGNBQWMsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDO1NBQzVCLENBQUMsQ0FBQyxJQUFJLENBQ0wsR0FBRyxDQUFDLFVBQUMsS0FBbUM7WUFDdEMsSUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFBLElBQUksSUFBSSxPQUFBLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBWixDQUFZLENBQUMsQ0FBQztZQUNwRCxJQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQUEsSUFBSSxJQUFJLE9BQUEsSUFBSSxDQUFDLE1BQU0sRUFBWCxDQUFXLENBQUMsQ0FBQztZQUVyRCxzRUFBc0U7WUFDdEUsd0VBQXdFO1lBQ3hFLHdGQUF3RjtZQUN4RixJQUFNLFdBQVcsR0FBRyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2hGLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNqQixXQUFXLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSSxJQUFJLE9BQUEsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBdEIsQ0FBc0IsQ0FBQyxDQUFDO1lBQ3BELE9BQU8sUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUMzQixDQUFDLENBQUMsRUFDRixXQUFXLENBQUMsQ0FBQyxDQUFDLENBQ2YsQ0FBQzs7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gseUNBQWMsR0FBZCxVQUFlLElBQW1CO1FBQ2hDLElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNoQyxPQUFPLENBQ0wsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUMzRixDQUFDO1NBQ0g7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFPRCxzQkFBSSxtQ0FBSztRQUxUOzs7O1dBSUc7YUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDM0IsQ0FBQzs7O09BQUE7SUFFRDs7T0FFRztJQUNILGtDQUFPLEdBQVA7UUFDRSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsOEJBQUcsR0FBSCxVQUFJLElBQW1CO1FBQ3JCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsaUNBQU0sR0FBTixVQUFPLElBQW1CO1FBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN0QixDQUFDOztnQkFwRTZCLFFBQVE7Z0JBQWtCLE1BQU07OztJQXZCbkQsZ0JBQWdCO1FBSDVCLFVBQVUsQ0FBQztZQUNWLFVBQVUsRUFBRSxNQUFNO1NBQ25CLENBQUM7T0FDVyxnQkFBZ0IsQ0E0RjVCOzJCQXRIRDtDQXNIQyxBQTVGRCxDQUFzQyxZQUFZLEdBNEZqRDtTQTVGWSxnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgc2hhcmVSZXBsYXkgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBFeHRlbnNpb25Qb2ludCxcbiAgZnJvbVRyaWdnZXIsXG4gIHNvcnRCeVByaW9yaXR5LFxuICBzdGF0ZVRvRmFjdG9yeVxufSBmcm9tICcuLi9jb21tb24vZXh0ZW5zaW9uLWhvb2tzJztcbmltcG9ydCB7IFN0YXRlU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9zdGF0ZS1zZXJ2aWNlLmFic3RyYWN0JztcbmltcG9ydCB7IE5hdmlnYXRvck5vZGUgfSBmcm9tICcuL25hdmlnYXRvci1ub2RlJztcbmltcG9ydCB7IE5hdmlnYXRvck5vZGVEYXRhIH0gZnJvbSAnLi9uYXZpZ2F0b3Itbm9kZS1kYXRhJztcbmltcG9ydCB7IE5hdmlnYXRvck5vZGVSb290IH0gZnJvbSAnLi9uYXZpZ2F0b3Itbm9kZS1yb290JztcblxuLyoqXG4gKiBBIGhvb2sgdG8gdXNlIGZvciBNdWx0aSBQcm92aWRlciBleHRlbnNpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBIT09LX05BVklHQVRPUl9OT0RFUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignTmF2aWdhdG9yTm9kZXNGYWN0b3J5Jyk7XG5cbi8qKlxuICogQSBzZXJ2aWNlIHdoaWNoIGRlZmluZXMgdGhlIG5hdmlnYXRvci5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgTmF2aWdhdG9yU2VydmljZSBleHRlbmRzIFN0YXRlU2VydmljZSBpbXBsZW1lbnRzIEV4dGVuc2lvblBvaW50PE5hdmlnYXRvck5vZGU+IHtcbiAgLyoqXG4gICAqIE5hdmlnYXRvciBtZW51IGl0ZW1zIG9ic2VydmFibGUuIEl0IGVtaXRzIHRoZSBjdXJyZW50IGxpc3Qgb2Ygbm9kZXMgaW4gdGhlIG5hdmlnYXRvci5cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBpdGVtcyQ6IE9ic2VydmFibGU8TmF2aWdhdG9yTm9kZVtdPjtcblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgZXh0ZW5zaW9uIGZhY3RvcmllcyBzdWJqZWN0LlxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIHJlYWRvbmx5IHJlZnJlc2hUcmlnZ2VyID0gbmV3IFN1YmplY3QoKTtcblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgcmVhZG9ubHkgc3RhdGUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxTZXQ8TmF2aWdhdG9yTm9kZT4+KG5ldyBTZXQ8TmF2aWdhdG9yTm9kZT4oKSk7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtZW51IGVudHJ5IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gVVJMIHNob3VsZCBiZSBleHBhbmRlZC5cbiAgICovXG4gIGZpcnN0VXJsID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGluamVjdG9yOiBJbmplY3RvciwgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcikge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgcm9vdE5vZGUgPSBuZXcgTmF2aWdhdG9yTm9kZVJvb3QoKTtcbiAgICB0aGlzLml0ZW1zJCA9IGZyb21UcmlnZ2VyKHJvdXRlciwgdGhpcy5yZWZyZXNoVHJpZ2dlciwgW1xuICAgICAgKCkgPT4gdGhpcy5pbmplY3Rvci5nZXQoSE9PS19OQVZJR0FUT1JfTk9ERVMsIFtdKSxcbiAgICAgIHN0YXRlVG9GYWN0b3J5KHRoaXMuc3RhdGUkKVxuICAgIF0pLnBpcGUoXG4gICAgICBtYXAoKG5vZGVzOiBQYXJ0aWFsPE5hdmlnYXRvck5vZGVEYXRhW10+KSA9PiB7XG4gICAgICAgIGNvbnN0IG5vUGFyZW50ID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4gIW5vZGUucGFyZW50KTtcbiAgICAgICAgY29uc3Qgd2l0aFBhcmVudCA9IG5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUucGFyZW50KTtcblxuICAgICAgICAvLyBCYXNlZCBvbiB0aGUgc29ydGVkTm9kZXMgYXJyYXksIHRoZSBub2RlcyBhcmUgc2VxdWVudGlhbGx5IGNyZWF0ZWQuXG4gICAgICAgIC8vIE5vZGVzIHNvcnRpbmcgaXMgZG9uZSBpbiB0d28gc3RlcHMgdG8gaGF2ZSB0aGUgdG9wLWxldmVsIG5vZGVzIGZpcnN0LlxuICAgICAgICAvLyBUaGlzIHdheSwgYnkgdGhlIHRpbWUgd2UgYXJlIGFkZGluZyBhIGNoaWxkIG5vZGUsIHRoZSBwYXJlbnQgbm9kZSBpcyBhbHJlYWR5IHByZXNlbnQuXG4gICAgICAgIGNvbnN0IHNvcnRlZE5vZGVzID0gc29ydEJ5UHJpb3JpdHkobm9QYXJlbnQpLmNvbmNhdChzb3J0QnlQcmlvcml0eSh3aXRoUGFyZW50KSk7XG4gICAgICAgIHJvb3ROb2RlLmVtcHR5KCk7XG4gICAgICAgIHNvcnRlZE5vZGVzLmZvckVhY2gobm9kZSA9PiByb290Tm9kZS5hZGRSb290KG5vZGUpKTtcbiAgICAgICAgcmV0dXJuIHJvb3ROb2RlLmNoaWxkcmVuO1xuICAgICAgfSksXG4gICAgICBzaGFyZVJlcGxheSgxKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZW5ldmVyIGEgbmF2aWdhdG9yIGVudHJ5IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gVVJMIHNob3VsZCBiZSBleHBhbmRlZC5cbiAgICogQHBhcmFtIHtOYXZpZ2F0b3JOb2RlfSBub2RlIE5hdmlnYXRvciBub2RlLlxuICAgKi9cbiAgb3Blbk9uRmlyc3RVcmwobm9kZTogTmF2aWdhdG9yTm9kZSkge1xuICAgIGlmICh0aGlzLmZpcnN0VXJsICYmICEhbm9kZS5wYXRoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnJvdXRlci5pc0FjdGl2ZShub2RlLnBhdGgsIG5vZGUucm91dGVyTGlua0V4YWN0KSB8fCBub2RlLm9wZW5PblN0YXJ0KHRoaXMucm91dGVyLnVybClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgc2V0IG9mIGFjdGlvbnMuXG4gICAqL1xuICBnZXQgc3RhdGUoKTogU2V0PE5hdmlnYXRvck5vZGU+IHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSQudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgZXh0ZW5zaW9uIGZhY3Rvcmllcy5cbiAgICovXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5yZWZyZXNoVHJpZ2dlci5uZXh0KDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgbm9kZSB0byB0aGUgbmF2aWdhdG9yLlxuICAgKiBAcGFyYW0ge05hdmlnYXRvck5vZGV9IG5vZGUgTmF2aWdhdG9yIG5vZGUgdG8gYWRkLlxuICAgKi9cbiAgYWRkKG5vZGU6IE5hdmlnYXRvck5vZGUpIHtcbiAgICB0aGlzLnN0YXRlLmFkZChub2RlKTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhlIG5hdmlnYXRvci5cbiAgICogQHBhcmFtIHtOYXZpZ2F0b3JOb2RlfSBub2RlIE5hdmlnYXRvciBub2RlIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZShub2RlOiBOYXZpZ2F0b3JOb2RlKSB7XG4gICAgdGhpcy5zdGF0ZS5kZWxldGUobm9kZSk7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxufVxuIl19