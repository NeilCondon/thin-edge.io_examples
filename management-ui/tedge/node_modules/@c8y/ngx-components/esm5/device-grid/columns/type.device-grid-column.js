import * as tslib_1 from "tslib";
import { gettext } from '@c8y/ngx-components';
import { BaseDeviceGridColumn } from './base.device-grid-column';
var TypeDeviceGridColumn = /** @class */ (function (_super) {
    tslib_1.__extends(TypeDeviceGridColumn, _super);
    function TypeDeviceGridColumn(initialColumnConfig) {
        var _this = _super.call(this, initialColumnConfig) || this;
        _this.name = 'type';
        _this.path = 'type';
        _this.header = gettext('Type');
        _this.filterable = true;
        _this.filteringConfig = {
            schema: {
                type: 'object',
                properties: {
                    types: {
                        type: 'array',
                        items: {
                            type: 'string'
                        }
                    }
                }
            },
            form: [
                {
                    key: 'types',
                    title: gettext('Show devices with type'),
                    add: gettext('Or'),
                    items: [
                        {
                            key: 'types[]',
                            notitle: true,
                            placeholder: gettext('e.g. MyType, you can use an asterisk (*) as wildcard character')
                        }
                    ]
                }
            ],
            getFilter: function (model) {
                var filter = {};
                if (model.types.length) {
                    filter.type = { __in: model.types };
                }
                return filter;
            }
        };
        _this.sortable = true;
        _this.sortingConfig = { pathSortingConfigs: [{ path: 'type' }] };
        return _this;
    }
    return TypeDeviceGridColumn;
}(BaseDeviceGridColumn));
export { TypeDeviceGridColumn };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5kZXZpY2UtZ3JpZC1jb2x1bW4uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYzh5L25neC1jb21wb25lbnRzL2RldmljZS1ncmlkLyIsInNvdXJjZXMiOlsiY29sdW1ucy90eXBlLmRldmljZS1ncmlkLWNvbHVtbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxxQkFBcUIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUVqRTtJQUEwQyxnREFBb0I7SUFDNUQsOEJBQVksbUJBQWtDO1FBQTlDLFlBQ0Usa0JBQU0sbUJBQW1CLENBQUMsU0E0QzNCO1FBMUNDLEtBQUksQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDO1FBQ25CLEtBQUksQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDO1FBQ25CLEtBQUksQ0FBQyxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTlCLEtBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLEtBQUksQ0FBQyxlQUFlLEdBQUc7WUFDckIsTUFBTSxFQUFFO2dCQUNOLElBQUksRUFBRSxRQUFRO2dCQUNkLFVBQVUsRUFBRTtvQkFDVixLQUFLLEVBQUU7d0JBQ0wsSUFBSSxFQUFFLE9BQU87d0JBQ2IsS0FBSyxFQUFFOzRCQUNMLElBQUksRUFBRSxRQUFRO3lCQUNmO3FCQUNGO2lCQUNGO2FBQ0Y7WUFDRCxJQUFJLEVBQUU7Z0JBQ0o7b0JBQ0UsR0FBRyxFQUFFLE9BQU87b0JBQ1osS0FBSyxFQUFFLE9BQU8sQ0FBQyx3QkFBd0IsQ0FBQztvQkFDeEMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUM7b0JBQ2xCLEtBQUssRUFBRTt3QkFDTDs0QkFDRSxHQUFHLEVBQUUsU0FBUzs0QkFDZCxPQUFPLEVBQUUsSUFBSTs0QkFDYixXQUFXLEVBQUUsT0FBTyxDQUFDLGdFQUFnRSxDQUFDO3lCQUN2RjtxQkFDRjtpQkFDRjthQUNGO1lBQ0QsU0FBUyxFQUFULFVBQVUsS0FBVTtnQkFDbEIsSUFBTSxNQUFNLEdBQVEsRUFBRSxDQUFDO2dCQUN2QixJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFO29CQUN0QixNQUFNLENBQUMsSUFBSSxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztpQkFDckM7Z0JBQ0QsT0FBTyxNQUFNLENBQUM7WUFDaEIsQ0FBQztTQUNGLENBQUM7UUFFRixLQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUNyQixLQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLENBQUM7O0lBQ2xFLENBQUM7SUFDSCwyQkFBQztBQUFELENBQUMsQUEvQ0QsQ0FBMEMsb0JBQW9CLEdBK0M3RCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldHRleHQsIENvbHVtbkNvbmZpZyB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgQmFzZURldmljZUdyaWRDb2x1bW4gfSBmcm9tICcuL2Jhc2UuZGV2aWNlLWdyaWQtY29sdW1uJztcblxuZXhwb3J0IGNsYXNzIFR5cGVEZXZpY2VHcmlkQ29sdW1uIGV4dGVuZHMgQmFzZURldmljZUdyaWRDb2x1bW4ge1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsQ29sdW1uQ29uZmlnPzogQ29sdW1uQ29uZmlnKSB7XG4gICAgc3VwZXIoaW5pdGlhbENvbHVtbkNvbmZpZyk7XG5cbiAgICB0aGlzLm5hbWUgPSAndHlwZSc7XG4gICAgdGhpcy5wYXRoID0gJ3R5cGUnO1xuICAgIHRoaXMuaGVhZGVyID0gZ2V0dGV4dCgnVHlwZScpO1xuXG4gICAgdGhpcy5maWx0ZXJhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmZpbHRlcmluZ0NvbmZpZyA9IHtcbiAgICAgIHNjaGVtYToge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHR5cGVzOiB7XG4gICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmb3JtOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBrZXk6ICd0eXBlcycsXG4gICAgICAgICAgdGl0bGU6IGdldHRleHQoJ1Nob3cgZGV2aWNlcyB3aXRoIHR5cGUnKSxcbiAgICAgICAgICBhZGQ6IGdldHRleHQoJ09yJyksXG4gICAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAga2V5OiAndHlwZXNbXScsXG4gICAgICAgICAgICAgIG5vdGl0bGU6IHRydWUsXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBnZXR0ZXh0KCdlLmcuIE15VHlwZSwgeW91IGNhbiB1c2UgYW4gYXN0ZXJpc2sgKCopIGFzIHdpbGRjYXJkIGNoYXJhY3RlcicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgZ2V0RmlsdGVyKG1vZGVsOiBhbnkpOiBhbnkge1xuICAgICAgICBjb25zdCBmaWx0ZXI6IGFueSA9IHt9O1xuICAgICAgICBpZiAobW9kZWwudHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZmlsdGVyLnR5cGUgPSB7IF9faW46IG1vZGVsLnR5cGVzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5zb3J0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5zb3J0aW5nQ29uZmlnID0geyBwYXRoU29ydGluZ0NvbmZpZ3M6IFt7IHBhdGg6ICd0eXBlJyB9XSB9O1xuICB9XG59XG4iXX0=